{"ast":null,"code":"/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\nfunction backtrace(node) {\n  var path = [[node.x, node.y]];\n  while (node.parent) {\n    node = node.parent;\n    path.push([node.x, node.y]);\n  }\n  return path.reverse();\n}\nexports.backtrace = backtrace;\n\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\nfunction biBacktrace(nodeA, nodeB) {\n  var pathA = backtrace(nodeA),\n    pathB = backtrace(nodeB);\n  return pathA.concat(pathB.reverse());\n}\nexports.biBacktrace = biBacktrace;\n\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\nfunction pathLength(path) {\n  var i,\n    sum = 0,\n    a,\n    b,\n    dx,\n    dy;\n  for (i = 1; i < path.length; ++i) {\n    a = path[i - 1];\n    b = path[i];\n    dx = a[0] - b[0];\n    dy = a[1] - b[1];\n    sum += Math.sqrt(dx * dx + dy * dy);\n  }\n  return sum;\n}\nexports.pathLength = pathLength;\n\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\nfunction interpolate(x0, y0, x1, y1) {\n  var abs = Math.abs,\n    line = [],\n    sx,\n    sy,\n    dx,\n    dy,\n    err,\n    e2;\n  dx = abs(x1 - x0);\n  dy = abs(y1 - y0);\n  sx = x0 < x1 ? 1 : -1;\n  sy = y0 < y1 ? 1 : -1;\n  err = dx - dy;\n  while (true) {\n    line.push([x0, y0]);\n    if (x0 === x1 && y0 === y1) {\n      break;\n    }\n    e2 = 2 * err;\n    if (e2 > -dy) {\n      err = err - dy;\n      x0 = x0 + sx;\n    }\n    if (e2 < dx) {\n      err = err + dx;\n      y0 = y0 + sy;\n    }\n  }\n  return line;\n}\nexports.interpolate = interpolate;\n\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\nfunction expandPath(path) {\n  var expanded = [],\n    len = path.length,\n    coord0,\n    coord1,\n    interpolated,\n    interpolatedLen,\n    i,\n    j;\n  if (len < 2) {\n    return expanded;\n  }\n  for (i = 0; i < len - 1; ++i) {\n    coord0 = path[i];\n    coord1 = path[i + 1];\n    interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\n    interpolatedLen = interpolated.length;\n    for (j = 0; j < interpolatedLen - 1; ++j) {\n      expanded.push(interpolated[j]);\n    }\n  }\n  expanded.push(path[len - 1]);\n  return expanded;\n}\nexports.expandPath = expandPath;\n\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\nfunction smoothenPath(grid, path) {\n  var len = path.length,\n    x0 = path[0][0],\n    // path start x\n    y0 = path[0][1],\n    // path start y\n    x1 = path[len - 1][0],\n    // path end x\n    y1 = path[len - 1][1],\n    // path end y\n    sx,\n    sy,\n    // current start coordinate\n    ex,\n    ey,\n    // current end coordinate\n    newPath,\n    i,\n    j,\n    coord,\n    line,\n    testCoord,\n    blocked;\n  sx = x0;\n  sy = y0;\n  newPath = [[sx, sy]];\n  for (i = 2; i < len; ++i) {\n    coord = path[i];\n    ex = coord[0];\n    ey = coord[1];\n    line = interpolate(sx, sy, ex, ey);\n    blocked = false;\n    for (j = 1; j < line.length; ++j) {\n      testCoord = line[j];\n      if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\n        blocked = true;\n        break;\n      }\n    }\n    if (blocked) {\n      lastValidCoord = path[i - 1];\n      newPath.push(lastValidCoord);\n      sx = lastValidCoord[0];\n      sy = lastValidCoord[1];\n    }\n  }\n  newPath.push([x1, y1]);\n  return newPath;\n}\nexports.smoothenPath = smoothenPath;\n\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\nfunction compressPath(path) {\n  // nothing to compress\n  if (path.length < 3) {\n    return path;\n  }\n  var compressed = [],\n    sx = path[0][0],\n    // start x\n    sy = path[0][1],\n    // start y\n    px = path[1][0],\n    // second point x\n    py = path[1][1],\n    // second point y\n    dx = px - sx,\n    // direction between the two points\n    dy = py - sy,\n    // direction between the two points\n    lx,\n    ly,\n    ldx,\n    ldy,\n    sq,\n    i;\n\n  // normalize the direction\n  sq = Math.sqrt(dx * dx + dy * dy);\n  dx /= sq;\n  dy /= sq;\n\n  // start the new path\n  compressed.push([sx, sy]);\n  for (i = 2; i < path.length; i++) {\n    // store the last point\n    lx = px;\n    ly = py;\n\n    // store the last direction\n    ldx = dx;\n    ldy = dy;\n\n    // next point\n    px = path[i][0];\n    py = path[i][1];\n\n    // next direction\n    dx = px - lx;\n    dy = py - ly;\n\n    // normalize\n    sq = Math.sqrt(dx * dx + dy * dy);\n    dx /= sq;\n    dy /= sq;\n\n    // if the direction has changed, store the point\n    if (dx !== ldx || dy !== ldy) {\n      compressed.push([lx, ly]);\n    }\n  }\n\n  // store the last point\n  compressed.push([px, py]);\n  return compressed;\n}\nexports.compressPath = compressPath;","map":{"version":3,"names":["backtrace","node","path","x","y","parent","push","reverse","exports","biBacktrace","nodeA","nodeB","pathA","pathB","concat","pathLength","i","sum","a","b","dx","dy","length","Math","sqrt","interpolate","x0","y0","x1","y1","abs","line","sx","sy","err","e2","expandPath","expanded","len","coord0","coord1","interpolated","interpolatedLen","j","smoothenPath","grid","ex","ey","newPath","coord","testCoord","blocked","isWalkableAt","lastValidCoord","compressPath","compressed","px","py","lx","ly","ldx","ldy","sq"],"sources":["C:/Users/samir/Diagram gen/diagram-sami/node_modules/pathfinding/src/core/Util.js"],"sourcesContent":["/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}