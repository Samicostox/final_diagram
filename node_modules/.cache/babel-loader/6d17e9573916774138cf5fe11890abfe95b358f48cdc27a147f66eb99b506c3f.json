{"ast":null,"code":"import * as React from 'react';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { PathFindingLinkWidget } from './PathFindingLinkWidget';\nimport * as _ from 'lodash';\nimport * as Path from 'paths-js/path';\nimport { DefaultLinkFactory } from '@projectstorm/react-diagrams-defaults';\nimport { AbstractDisplacementState, Action, InputType } from '@projectstorm/react-canvas-core';\nexport class PathFindingLinkFactory extends DefaultLinkFactory {\n  constructor() {\n    super(PathFindingLinkFactory.NAME);\n    this.ROUTING_SCALING_FACTOR = 5;\n    // calculated only when smart routing is active\n    this.canvasMatrix = [];\n    this.routingMatrix = [];\n    // used when at least one element has negative coordinates\n    this.hAdjustmentFactor = 0;\n    this.vAdjustmentFactor = 0;\n    /**\n     * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n     * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n     */\n    this.calculateMatrixDimensions = () => {\n      const allNodesCoords = _.values(this.engine.getModel().getNodes()).map(item => ({\n        x: item.getX(),\n        width: item.width,\n        y: item.getY(),\n        height: item.height\n      }));\n      const allLinks = _.values(this.engine.getModel().getLinks());\n      const allPortsCoords = _.flatMap(allLinks.map(link => [link.getSourcePort(), link.getTargetPort()])).filter(port => port !== null).map(item => ({\n        x: item.getX(),\n        width: item.width,\n        y: item.getY(),\n        height: item.height\n      }));\n      const allPointsCoords = _.flatMap(allLinks.map(link => link.getPoints())).map(item => ({\n        // points don't have width/height, so let's just use 0\n        x: item.getX(),\n        width: 0,\n        y: item.getY(),\n        height: 0\n      }));\n      const sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n      const canvas = this.engine.getCanvas();\n      const concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n      const minX = Math.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n      const maxXElement = _.maxBy(concatedCoords, item => sumProps(item, ['x', 'width']));\n      const maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n      const minYCoords = _.minBy(concatedCoords, 'y');\n      const minY = Math.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n      const maxYElement = _.maxBy(concatedCoords, item => sumProps(item, ['y', 'height']));\n      const maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n      return {\n        width: Math.ceil(Math.abs(minX) + maxX),\n        hAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n        height: Math.ceil(Math.abs(minY) + maxY),\n        vAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n      };\n    };\n    /**\n     * Updates (by reference) where nodes will be drawn on the matrix passed in.\n     */\n    this.markNodes = matrix => {\n      _.values(this.engine.getModel().getNodes()).forEach(node => {\n        const startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n        const endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n        const startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n        const endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n        for (let x = startX - 1; x <= endX + 1; x++) {\n          for (let y = startY - 1; y < endY + 1; y++) {\n            this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n          }\n        }\n      });\n    };\n    /**\n     * Updates (by reference) where ports will be drawn on the matrix passed in.\n     */\n    this.markPorts = matrix => {\n      const allElements = _.flatMap(_.values(this.engine.getModel().getLinks()).map(link => [].concat(link.getSourcePort(), link.getTargetPort())));\n      allElements.filter(port => port !== null).forEach(port => {\n        const startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n        const endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n        const startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n        const endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n        for (let x = startX - 1; x <= endX + 1; x++) {\n          for (let y = startY - 1; y < endY + 1; y++) {\n            this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n          }\n        }\n      });\n    };\n    this.markMatrixPoint = (matrix, x, y) => {\n      if (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n        matrix[y][x] = 1;\n      }\n    };\n  }\n  setDiagramEngine(engine) {\n    super.setDiagramEngine(engine);\n    // listen for drag changes\n    engine.getStateMachine().registerListener({\n      stateChanged: event => {\n        if (event.newState instanceof AbstractDisplacementState) {\n          const deRegister = engine.getActionEventBus().registerAction(new Action({\n            type: InputType.MOUSE_UP,\n            fire: () => {\n              this.calculateRoutingMatrix();\n              engine.repaintCanvas();\n              deRegister();\n            }\n          }));\n        }\n      }\n    });\n    this.listener = engine.registerListener({\n      canvasReady: () => {\n        _.defer(() => {\n          this.calculateRoutingMatrix();\n          engine.repaintCanvas();\n        });\n      }\n    });\n  }\n  setFactoryBank(bank) {\n    super.setFactoryBank(bank);\n    if (!bank && this.listener) {\n      this.listener.deregister();\n    }\n  }\n  generateReactWidget(event) {\n    return React.createElement(PathFindingLinkWidget, {\n      diagramEngine: this.engine,\n      link: event.model,\n      factory: this\n    });\n  }\n  generateModel(event) {\n    return new PathFindingLinkModel();\n  }\n  /**\n   * A representation of the canvas in the following format:\n   *\n   * +-----------------+\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * +-----------------+\n   *\n   * In which all walkable points are marked by zeros.\n   * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n   */\n  getCanvasMatrix() {\n    if (this.canvasMatrix.length === 0) {\n      this.calculateCanvasMatrix();\n    }\n    return this.canvasMatrix;\n  }\n  calculateCanvasMatrix() {\n    const {\n      width: canvasWidth,\n      hAdjustmentFactor,\n      height: canvasHeight,\n      vAdjustmentFactor\n    } = this.calculateMatrixDimensions();\n    this.hAdjustmentFactor = hAdjustmentFactor;\n    this.vAdjustmentFactor = vAdjustmentFactor;\n    const matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n    const matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n    this.canvasMatrix = _.range(0, matrixHeight).map(() => {\n      return new Array(matrixWidth).fill(0);\n    });\n  }\n  /**\n   * A representation of the canvas in the following format:\n   *\n   * +-----------------+\n   * | 0 0 1 1 0 0 0 0 |\n   * | 0 0 1 1 0 0 1 1 |\n   * | 0 0 0 0 0 0 1 1 |\n   * | 1 1 0 0 0 0 0 0 |\n   * | 1 1 0 0 0 0 0 0 |\n   * +-----------------+\n   *\n   * In which all points blocked by a node (and its ports) are\n   * marked as 1; points were there is nothing (ie, free) receive 0.\n   */\n  getRoutingMatrix() {\n    if (this.routingMatrix.length === 0) {\n      this.calculateRoutingMatrix();\n    }\n    return this.routingMatrix;\n  }\n  calculateRoutingMatrix() {\n    const matrix = _.cloneDeep(this.getCanvasMatrix());\n    // nodes need to be marked as blocked points\n    this.markNodes(matrix);\n    // same thing for ports\n    this.markPorts(matrix);\n    this.routingMatrix = matrix;\n  }\n  /**\n   * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n   * We use the functions below to translate back and forth between these coordinates, relying on the\n   * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n   */\n  translateRoutingX(x, reverse = false) {\n    return x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n  }\n  translateRoutingY(y, reverse = false) {\n    return y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n  }\n  generateDynamicPath(pathCoords) {\n    let path = Path();\n    path = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n    pathCoords.slice(1).forEach(coords => {\n      path = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n    });\n    return path.print();\n  }\n}\nPathFindingLinkFactory.NAME = 'pathfinding';","map":{"version":3,"names":["React","PathFindingLinkModel","PathFindingLinkWidget","_","Path","DefaultLinkFactory","AbstractDisplacementState","Action","InputType","PathFindingLinkFactory","constructor","NAME","ROUTING_SCALING_FACTOR","canvasMatrix","routingMatrix","hAdjustmentFactor","vAdjustmentFactor","calculateMatrixDimensions","allNodesCoords","values","engine","getModel","getNodes","map","item","x","getX","width","y","getY","height","allLinks","getLinks","allPortsCoords","flatMap","link","getSourcePort","getTargetPort","filter","port","allPointsCoords","getPoints","sumProps","object","props","reduce","acc","prop","get","canvas","getCanvas","concatedCoords","concat","minX","Math","floor","min","minBy","maxXElement","maxBy","maxX","max","offsetWidth","minYCoords","minY","maxYElement","maxY","offsetHeight","ceil","abs","markNodes","matrix","forEach","node","startX","endX","startY","endY","markMatrixPoint","translateRoutingX","translateRoutingY","markPorts","allElements","undefined","setDiagramEngine","getStateMachine","registerListener","stateChanged","event","newState","deRegister","getActionEventBus","registerAction","type","MOUSE_UP","fire","calculateRoutingMatrix","repaintCanvas","listener","canvasReady","defer","setFactoryBank","bank","deregister","generateReactWidget","createElement","diagramEngine","model","factory","generateModel","getCanvasMatrix","length","calculateCanvasMatrix","canvasWidth","canvasHeight","matrixWidth","matrixHeight","range","Array","fill","getRoutingMatrix","cloneDeep","reverse","generateDynamicPath","pathCoords","path","moveto","slice","coords","lineto","print"],"sources":["C:\\Users\\samir\\Diagram gen\\diagram-sami\\node_modules\\@projectstorm\\react-diagrams-routing\\src\\link\\PathFindingLinkFactory.tsx"],"sourcesContent":["import * as React from 'react';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { PathFindingLinkWidget } from './PathFindingLinkWidget';\nimport * as _ from 'lodash';\nimport * as Path from 'paths-js/path';\nimport { DefaultLinkFactory } from '@projectstorm/react-diagrams-defaults';\nimport {\n\tAbstractDisplacementState,\n\tAbstractFactory,\n\tAction,\n\tFactoryBank,\n\tInputType,\n\tListenerHandle\n} from '@projectstorm/react-canvas-core';\n\nexport class PathFindingLinkFactory extends DefaultLinkFactory<PathFindingLinkModel> {\n\tROUTING_SCALING_FACTOR: number = 5;\n\n\t// calculated only when smart routing is active\n\tcanvasMatrix: number[][] = [];\n\troutingMatrix: number[][] = [];\n\n\t// used when at least one element has negative coordinates\n\thAdjustmentFactor: number = 0;\n\tvAdjustmentFactor: number = 0;\n\n\tstatic NAME = 'pathfinding';\n\tlistener: ListenerHandle;\n\n\tconstructor() {\n\t\tsuper(PathFindingLinkFactory.NAME);\n\t}\n\n\tsetDiagramEngine(engine: DiagramEngine): void {\n\t\tsuper.setDiagramEngine(engine);\n\n\t\t// listen for drag changes\n\t\tengine.getStateMachine().registerListener({\n\t\t\tstateChanged: (event) => {\n\t\t\t\tif (event.newState instanceof AbstractDisplacementState) {\n\t\t\t\t\tconst deRegister = engine.getActionEventBus().registerAction(\n\t\t\t\t\t\tnew Action<DiagramEngine>({\n\t\t\t\t\t\t\ttype: InputType.MOUSE_UP,\n\t\t\t\t\t\t\tfire: () => {\n\t\t\t\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t\t\t\t\tdeRegister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.listener = engine.registerListener({\n\t\t\tcanvasReady: () => {\n\t\t\t\t_.defer(() => {\n\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tsetFactoryBank(bank: FactoryBank<AbstractFactory>): void {\n\t\tsuper.setFactoryBank(bank);\n\t\tif (!bank && this.listener) {\n\t\t\tthis.listener.deregister();\n\t\t}\n\t}\n\n\tgenerateReactWidget(event): JSX.Element {\n\t\treturn <PathFindingLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\n\t}\n\n\tgenerateModel(event): PathFindingLinkModel {\n\t\treturn new PathFindingLinkModel();\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all walkable points are marked by zeros.\n\t * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n\t */\n\tgetCanvasMatrix(): number[][] {\n\t\tif (this.canvasMatrix.length === 0) {\n\t\t\tthis.calculateCanvasMatrix();\n\t\t}\n\n\t\treturn this.canvasMatrix;\n\t}\n\tcalculateCanvasMatrix() {\n\t\tconst {\n\t\t\twidth: canvasWidth,\n\t\t\thAdjustmentFactor,\n\t\t\theight: canvasHeight,\n\t\t\tvAdjustmentFactor\n\t\t} = this.calculateMatrixDimensions();\n\n\t\tthis.hAdjustmentFactor = hAdjustmentFactor;\n\t\tthis.vAdjustmentFactor = vAdjustmentFactor;\n\n\t\tconst matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n\t\tconst matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n\n\t\tthis.canvasMatrix = _.range(0, matrixHeight).map(() => {\n\t\t\treturn new Array(matrixWidth).fill(0);\n\t\t});\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 1 1 0 0 0 0 |\n\t * | 0 0 1 1 0 0 1 1 |\n\t * | 0 0 0 0 0 0 1 1 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all points blocked by a node (and its ports) are\n\t * marked as 1; points were there is nothing (ie, free) receive 0.\n\t */\n\tgetRoutingMatrix(): number[][] {\n\t\tif (this.routingMatrix.length === 0) {\n\t\t\tthis.calculateRoutingMatrix();\n\t\t}\n\n\t\treturn this.routingMatrix;\n\t}\n\tcalculateRoutingMatrix(): void {\n\t\tconst matrix = _.cloneDeep(this.getCanvasMatrix());\n\n\t\t// nodes need to be marked as blocked points\n\t\tthis.markNodes(matrix);\n\t\t// same thing for ports\n\t\tthis.markPorts(matrix);\n\n\t\tthis.routingMatrix = matrix;\n\t}\n\n\t/**\n\t * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n\t * We use the functions below to translate back and forth between these coordinates, relying on the\n\t * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n\t */\n\ttranslateRoutingX(x: number, reverse: boolean = false) {\n\t\treturn x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\ttranslateRoutingY(y: number, reverse: boolean = false) {\n\t\treturn y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\n\t/**\n\t * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n\t * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n\t */\n\tcalculateMatrixDimensions = (): {\n\t\twidth: number;\n\t\thAdjustmentFactor: number;\n\t\theight: number;\n\t\tvAdjustmentFactor: number;\n\t} => {\n\t\tconst allNodesCoords = _.values(this.engine.getModel().getNodes()).map((item) => ({\n\t\t\tx: item.getX(),\n\t\t\twidth: item.width,\n\t\t\ty: item.getY(),\n\t\t\theight: item.height\n\t\t}));\n\n\t\tconst allLinks = _.values(this.engine.getModel().getLinks());\n\t\tconst allPortsCoords = _.flatMap(allLinks.map((link) => [link.getSourcePort(), link.getTargetPort()]))\n\t\t\t.filter((port) => port !== null)\n\t\t\t.map((item) => ({\n\t\t\t\tx: item.getX(),\n\t\t\t\twidth: item.width,\n\t\t\t\ty: item.getY(),\n\t\t\t\theight: item.height\n\t\t\t}));\n\t\tconst allPointsCoords = _.flatMap(allLinks.map((link) => link.getPoints())).map((item) => ({\n\t\t\t// points don't have width/height, so let's just use 0\n\t\t\tx: item.getX(),\n\t\t\twidth: 0,\n\t\t\ty: item.getY(),\n\t\t\theight: 0\n\t\t}));\n\n\t\tconst sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n\n\t\tconst canvas = this.engine.getCanvas() as HTMLDivElement;\n\t\tconst concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n\t\tconst minX =\n\t\t\tMath.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) *\n\t\t\tthis.ROUTING_SCALING_FACTOR;\n\t\tconst maxXElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['x', 'width']));\n\t\tconst maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n\t\tconst minYCoords = _.minBy(concatedCoords, 'y');\n\t\tconst minY =\n\t\t\tMath.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\t\tconst maxYElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['y', 'height']));\n\t\tconst maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n\n\t\treturn {\n\t\t\twidth: Math.ceil(Math.abs(minX) + maxX),\n\t\t\thAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n\t\t\theight: Math.ceil(Math.abs(minY) + maxY),\n\t\t\tvAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n\t\t};\n\t};\n\n\t/**\n\t * Updates (by reference) where nodes will be drawn on the matrix passed in.\n\t */\n\tmarkNodes = (matrix: number[][]): void => {\n\t\t_.values(this.engine.getModel().getNodes()).forEach((node) => {\n\t\t\tconst startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Updates (by reference) where ports will be drawn on the matrix passed in.\n\t */\n\tmarkPorts = (matrix: number[][]): void => {\n\t\tconst allElements = _.flatMap(\n\t\t\t_.values(this.engine.getModel().getLinks()).map((link) => [].concat(link.getSourcePort(), link.getTargetPort()))\n\t\t);\n\t\tallElements\n\t\t\t.filter((port) => port !== null)\n\t\t\t.forEach((port) => {\n\t\t\t\tconst startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t};\n\n\tmarkMatrixPoint = (matrix: number[][], x: number, y: number) => {\n\t\tif (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n\t\t\tmatrix[y][x] = 1;\n\t\t}\n\t};\n\n\tgenerateDynamicPath(pathCoords: number[][]) {\n\t\tlet path = Path();\n\t\tpath = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n\t\tpathCoords.slice(1).forEach((coords) => {\n\t\t\tpath = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n\t\t});\n\t\treturn path.print();\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}