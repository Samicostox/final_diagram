{"ast":null,"code":"/**\r\n * @author imor / https://github.com/imor\r\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\nfunction JPFNeverMoveDiagonally(opt) {\n  JumpPointFinderBase.call(this, opt);\n}\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\n\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\nJPFNeverMoveDiagonally.prototype._jump = function (x, y, px, py) {\n  var grid = this.grid,\n    dx = x - px,\n    dy = y - py;\n  if (!grid.isWalkableAt(x, y)) {\n    return null;\n  }\n  if (this.trackJumpRecursion === true) {\n    grid.getNodeAt(x, y).tested = true;\n  }\n  if (grid.getNodeAt(x, y) === this.endNode) {\n    return [x, y];\n  }\n  if (dx !== 0) {\n    if (grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1) || grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1)) {\n      return [x, y];\n    }\n  } else if (dy !== 0) {\n    if (grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy) || grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy)) {\n      return [x, y];\n    }\n    //When moving vertically, must check for horizontal jump points\n    if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n      return [x, y];\n    }\n  } else {\n    throw new Error(\"Only horizontal and vertical movements are allowed\");\n  }\n  return this._jump(x + dx, y + dy, x, y);\n};\n\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\nJPFNeverMoveDiagonally.prototype._findNeighbors = function (node) {\n  var parent = node.parent,\n    x = node.x,\n    y = node.y,\n    grid = this.grid,\n    px,\n    py,\n    nx,\n    ny,\n    dx,\n    dy,\n    neighbors = [],\n    neighborNodes,\n    neighborNode,\n    i,\n    l;\n\n  // directed pruning: can ignore most neighbors, unless forced.\n  if (parent) {\n    px = parent.x;\n    py = parent.y;\n    // get the normalized direction of travel\n    dx = (x - px) / Math.max(Math.abs(x - px), 1);\n    dy = (y - py) / Math.max(Math.abs(y - py), 1);\n    if (dx !== 0) {\n      if (grid.isWalkableAt(x, y - 1)) {\n        neighbors.push([x, y - 1]);\n      }\n      if (grid.isWalkableAt(x, y + 1)) {\n        neighbors.push([x, y + 1]);\n      }\n      if (grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y]);\n      }\n    } else if (dy !== 0) {\n      if (grid.isWalkableAt(x - 1, y)) {\n        neighbors.push([x - 1, y]);\n      }\n      if (grid.isWalkableAt(x + 1, y)) {\n        neighbors.push([x + 1, y]);\n      }\n      if (grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x, y + dy]);\n      }\n    }\n  }\n  // return all neighbors\n  else {\n    neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\n    for (i = 0, l = neighborNodes.length; i < l; ++i) {\n      neighborNode = neighborNodes[i];\n      neighbors.push([neighborNode.x, neighborNode.y]);\n    }\n  }\n  return neighbors;\n};\nmodule.exports = JPFNeverMoveDiagonally;","map":{"version":3,"names":["JumpPointFinderBase","require","DiagonalMovement","JPFNeverMoveDiagonally","opt","call","prototype","constructor","_jump","x","y","px","py","grid","dx","dy","isWalkableAt","trackJumpRecursion","getNodeAt","tested","endNode","Error","_findNeighbors","node","parent","nx","ny","neighbors","neighborNodes","neighborNode","i","l","Math","max","abs","push","getNeighbors","Never","length","module","exports"],"sources":["C:/Users/samir/Diagram gen/diagram-sami/node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js"],"sourcesContent":["/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}