{"ast":null,"code":"/**\r\n * @author aniero / https://github.com/aniero\r\n */\nvar DiagonalMovement = require('../core/DiagonalMovement');\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\n\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\nfunction JumpPointFinder(opt) {\n  opt = opt || {};\n  if (opt.diagonalMovement === DiagonalMovement.Never) {\n    return new JPFNeverMoveDiagonally(opt);\n  } else if (opt.diagonalMovement === DiagonalMovement.Always) {\n    return new JPFAlwaysMoveDiagonally(opt);\n  } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\n    return new JPFMoveDiagonallyIfNoObstacles(opt);\n  } else {\n    return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\n  }\n}\nmodule.exports = JumpPointFinder;","map":{"version":3,"names":["DiagonalMovement","require","JPFNeverMoveDiagonally","JPFAlwaysMoveDiagonally","JPFMoveDiagonallyIfNoObstacles","JPFMoveDiagonallyIfAtMostOneObstacle","JumpPointFinder","opt","diagonalMovement","Never","Always","OnlyWhenNoObstacles","module","exports"],"sources":["C:/Users/samir/Diagram gen/diagram-sami/node_modules/pathfinding/src/finders/JumpPointFinder.js"],"sourcesContent":["/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\r\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\r\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,IAAIA,gBAAgB,GAAGC,OAAO,CAAC,0BAA0B,CAAC;AAC1D,IAAIC,sBAAsB,GAAGD,OAAO,CAAC,0BAA0B,CAAC;AAChE,IAAIE,uBAAuB,GAAGF,OAAO,CAAC,2BAA2B,CAAC;AAClE,IAAIG,8BAA8B,GAAGH,OAAO,CAAC,kCAAkC,CAAC;AAChF,IAAII,oCAAoC,GAAGJ,OAAO,CAAC,wCAAwC,CAAC;;AAE5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,eAAeA,CAACC,GAAG,EAAE;EAC1BA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;EACf,IAAIA,GAAG,CAACC,gBAAgB,KAAKR,gBAAgB,CAACS,KAAK,EAAE;IACjD,OAAO,IAAIP,sBAAsB,CAACK,GAAG,CAAC;EAC1C,CAAC,MAAM,IAAIA,GAAG,CAACC,gBAAgB,KAAKR,gBAAgB,CAACU,MAAM,EAAE;IACzD,OAAO,IAAIP,uBAAuB,CAACI,GAAG,CAAC;EAC3C,CAAC,MAAM,IAAIA,GAAG,CAACC,gBAAgB,KAAKR,gBAAgB,CAACW,mBAAmB,EAAE;IACtE,OAAO,IAAIP,8BAA8B,CAACG,GAAG,CAAC;EAClD,CAAC,MAAM;IACH,OAAO,IAAIF,oCAAoC,CAACE,GAAG,CAAC;EACxD;AACJ;AAEAK,MAAM,CAACC,OAAO,GAAGP,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}