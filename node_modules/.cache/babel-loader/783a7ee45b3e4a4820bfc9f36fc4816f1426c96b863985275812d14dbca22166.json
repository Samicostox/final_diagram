{"ast":null,"code":"import { AbstractDisplacementState, Action, InputType } from '@projectstorm/react-canvas-core';\nimport { PortModel } from '../entities/port/PortModel';\nexport class DragNewLinkState extends AbstractDisplacementState {\n  constructor(options = {}) {\n    super({\n      name: 'drag-new-link'\n    });\n    this.config = Object.assign({\n      allowLooseLinks: true,\n      allowLinksFromLockedPorts: false\n    }, options);\n    this.registerAction(new Action({\n      type: InputType.MOUSE_DOWN,\n      fire: event => {\n        this.port = this.engine.getMouseElement(event.event);\n        if (!this.config.allowLinksFromLockedPorts && this.port.isLocked()) {\n          this.eject();\n          return;\n        }\n        this.link = this.port.createLinkModel();\n        // if no link is given, just eject the state\n        if (!this.link) {\n          this.eject();\n          return;\n        }\n        this.link.setSelected(true);\n        this.link.setSourcePort(this.port);\n        this.engine.getModel().addLink(this.link);\n        this.port.reportPosition();\n      }\n    }));\n    this.registerAction(new Action({\n      type: InputType.MOUSE_UP,\n      fire: event => {\n        const model = this.engine.getMouseElement(event.event);\n        // check to see if we connected to a new port\n        if (model instanceof PortModel) {\n          if (this.port.canLinkToPort(model)) {\n            this.link.setTargetPort(model);\n            model.reportPosition();\n            this.engine.repaintCanvas();\n            return;\n          } else {\n            this.link.remove();\n            this.engine.repaintCanvas();\n            return;\n          }\n        }\n        if (!this.config.allowLooseLinks) {\n          this.link.remove();\n          this.engine.repaintCanvas();\n        }\n      }\n    }));\n  }\n  /**\n   * Calculates the link's far-end point position on mouse move.\n   * In order to be as precise as possible the mouse initialXRelative & initialYRelative are taken into account as well\n   * as the possible engine offset\n   */\n  fireMouseMoved(event) {\n    const portPos = this.port.getPosition();\n    const zoomLevelPercentage = this.engine.getModel().getZoomLevel() / 100;\n    const engineOffsetX = this.engine.getModel().getOffsetX() / zoomLevelPercentage;\n    const engineOffsetY = this.engine.getModel().getOffsetY() / zoomLevelPercentage;\n    const initialXRelative = this.initialXRelative / zoomLevelPercentage;\n    const initialYRelative = this.initialYRelative / zoomLevelPercentage;\n    const linkNextX = portPos.x - engineOffsetX + (initialXRelative - portPos.x) + event.virtualDisplacementX;\n    const linkNextY = portPos.y - engineOffsetY + (initialYRelative - portPos.y) + event.virtualDisplacementY;\n    this.link.getLastPoint().setPosition(linkNextX, linkNextY);\n    this.engine.repaintCanvas();\n  }\n}","map":{"version":3,"names":["AbstractDisplacementState","Action","InputType","PortModel","DragNewLinkState","constructor","options","name","config","Object","assign","allowLooseLinks","allowLinksFromLockedPorts","registerAction","type","MOUSE_DOWN","fire","event","port","engine","getMouseElement","isLocked","eject","link","createLinkModel","setSelected","setSourcePort","getModel","addLink","reportPosition","MOUSE_UP","model","canLinkToPort","setTargetPort","repaintCanvas","remove","fireMouseMoved","portPos","getPosition","zoomLevelPercentage","getZoomLevel","engineOffsetX","getOffsetX","engineOffsetY","getOffsetY","initialXRelative","initialYRelative","linkNextX","x","virtualDisplacementX","linkNextY","y","virtualDisplacementY","getLastPoint","setPosition"],"sources":["C:\\Users\\samir\\Diagram gen\\diagram-sami\\node_modules\\@projectstorm\\react-diagrams-core\\src\\states\\DragNewLinkState.ts"],"sourcesContent":["import {\n\tAbstractDisplacementState,\n\tAbstractDisplacementStateEvent,\n\tAction,\n\tActionEvent,\n\tInputType\n} from '@projectstorm/react-canvas-core';\nimport { PortModel } from '../entities/port/PortModel';\nimport { MouseEvent } from 'react';\nimport { LinkModel } from '../entities/link/LinkModel';\nimport { DiagramEngine } from '../DiagramEngine';\n\nexport interface DragNewLinkStateOptions {\n\t/**\n\t * If enabled, the links will stay on the canvas if they dont connect to a port\n\t * when dragging finishes\n\t */\n\tallowLooseLinks?: boolean;\n\t/**\n\t * If enabled, then a link can still be drawn from the port even if it is locked\n\t */\n\tallowLinksFromLockedPorts?: boolean;\n}\n\nexport class DragNewLinkState extends AbstractDisplacementState<DiagramEngine> {\n\tport: PortModel;\n\tlink: LinkModel;\n\tconfig: DragNewLinkStateOptions;\n\n\tconstructor(options: DragNewLinkStateOptions = {}) {\n\t\tsuper({ name: 'drag-new-link' });\n\n\t\tthis.config = {\n\t\t\tallowLooseLinks: true,\n\t\t\tallowLinksFromLockedPorts: false,\n\t\t\t...options\n\t\t};\n\n\t\tthis.registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.MOUSE_DOWN,\n\t\t\t\tfire: (event: ActionEvent<MouseEvent, PortModel>) => {\n\t\t\t\t\tthis.port = this.engine.getMouseElement(event.event) as PortModel;\n\t\t\t\t\tif (!this.config.allowLinksFromLockedPorts && this.port.isLocked()) {\n\t\t\t\t\t\tthis.eject();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.link = this.port.createLinkModel();\n\n\t\t\t\t\t// if no link is given, just eject the state\n\t\t\t\t\tif (!this.link) {\n\t\t\t\t\t\tthis.eject();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.link.setSelected(true);\n\t\t\t\t\tthis.link.setSourcePort(this.port);\n\t\t\t\t\tthis.engine.getModel().addLink(this.link);\n\t\t\t\t\tthis.port.reportPosition();\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\tthis.registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.MOUSE_UP,\n\t\t\t\tfire: (event: ActionEvent<MouseEvent>) => {\n\t\t\t\t\tconst model = this.engine.getMouseElement(event.event);\n\t\t\t\t\t// check to see if we connected to a new port\n\t\t\t\t\tif (model instanceof PortModel) {\n\t\t\t\t\t\tif (this.port.canLinkToPort(model)) {\n\t\t\t\t\t\t\tthis.link.setTargetPort(model);\n\t\t\t\t\t\t\tmodel.reportPosition();\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.link.remove();\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this.config.allowLooseLinks) {\n\t\t\t\t\t\tthis.link.remove();\n\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Calculates the link's far-end point position on mouse move.\n\t * In order to be as precise as possible the mouse initialXRelative & initialYRelative are taken into account as well\n\t * as the possible engine offset\n\t */\n\tfireMouseMoved(event: AbstractDisplacementStateEvent): any {\n\t\tconst portPos = this.port.getPosition();\n\t\tconst zoomLevelPercentage = this.engine.getModel().getZoomLevel() / 100;\n\t\tconst engineOffsetX = this.engine.getModel().getOffsetX() / zoomLevelPercentage;\n\t\tconst engineOffsetY = this.engine.getModel().getOffsetY() / zoomLevelPercentage;\n\t\tconst initialXRelative = this.initialXRelative / zoomLevelPercentage;\n\t\tconst initialYRelative = this.initialYRelative / zoomLevelPercentage;\n\t\tconst linkNextX = portPos.x - engineOffsetX + (initialXRelative - portPos.x) + event.virtualDisplacementX;\n\t\tconst linkNextY = portPos.y - engineOffsetY + (initialYRelative - portPos.y) + event.virtualDisplacementY;\n\n\t\tthis.link.getLastPoint().setPosition(linkNextX, linkNextY);\n\t\tthis.engine.repaintCanvas();\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}