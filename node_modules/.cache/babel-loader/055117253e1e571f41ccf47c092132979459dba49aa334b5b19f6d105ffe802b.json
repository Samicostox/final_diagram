{"ast":null,"code":"import * as PF from 'pathfinding';\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\nconst pathFinderInstance = new PF.JumpPointFinder({\n  heuristic: PF.Heuristic.manhattan,\n  diagonalMovement: PF.DiagonalMovement.Never\n});\nexport class PathFinding {\n  constructor(factory) {\n    this.instance = pathFinderInstance;\n    this.factory = factory;\n  }\n  /**\n   * Taking as argument a fully unblocked walking matrix, this method\n   * finds a direct path from point A to B.\n   */\n  calculateDirectPath(from, to) {\n    const matrix = this.factory.getCanvasMatrix();\n    const grid = new PF.Grid(matrix);\n    return pathFinderInstance.findPath(this.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)), grid);\n  }\n  /**\n   * Using @link{#calculateDirectPath}'s result as input, we here\n   * determine the first walkable point found in the matrix that includes\n   * blocked paths.\n   */\n  calculateLinkStartEndCoords(matrix, path) {\n    const startIndex = path.findIndex(point => {\n      if (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;else return false;\n    });\n    const endIndex = path.length - 1 - path.slice().reverse().findIndex(point => {\n      if (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;else return false;\n    });\n    // are we trying to create a path exclusively through blocked areas?\n    // if so, let's fallback to the linear routing\n    if (startIndex === -1 || endIndex === -1) {\n      return undefined;\n    }\n    const pathToStart = path.slice(0, startIndex);\n    const pathToEnd = path.slice(endIndex);\n    return {\n      start: {\n        x: path[startIndex][0],\n        y: path[startIndex][1]\n      },\n      end: {\n        x: path[endIndex][0],\n        y: path[endIndex][1]\n      },\n      pathToStart,\n      pathToEnd\n    };\n  }\n  /**\n   * Puts everything together: merges the paths from/to the centre of the ports,\n   * with the path calculated around other elements.\n   */\n  calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd) {\n    // generate the path based on the matrix with obstacles\n    const grid = new PF.Grid(routingMatrix);\n    const dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n    // aggregate everything to have the calculated path ready for rendering\n    const pathCoords = pathToStart.concat(dynamicPath, pathToEnd).map(coords => [this.factory.translateRoutingX(coords[0], true), this.factory.translateRoutingY(coords[1], true)]);\n    return PF.Util.compressPath(pathCoords);\n  }\n}","map":{"version":3,"names":["PF","pathFinderInstance","JumpPointFinder","heuristic","Heuristic","manhattan","diagonalMovement","DiagonalMovement","Never","PathFinding","constructor","factory","instance","calculateDirectPath","from","to","matrix","getCanvasMatrix","grid","Grid","findPath","translateRoutingX","Math","floor","getX","ROUTING_SCALING_FACTOR","translateRoutingY","getY","calculateLinkStartEndCoords","path","startIndex","findIndex","point","endIndex","length","slice","reverse","undefined","pathToStart","pathToEnd","start","x","y","end","calculateDynamicPath","routingMatrix","dynamicPath","pathCoords","concat","map","coords","Util","compressPath"],"sources":["C:\\Users\\samir\\Diagram gen\\diagram-sami\\node_modules\\@projectstorm\\react-diagrams-routing\\src\\engine\\PathFinding.ts"],"sourcesContent":["import * as PF from 'pathfinding';\nimport { PathFindingLinkFactory } from '../link/PathFindingLinkFactory';\nimport { PointModel } from '@projectstorm/react-diagrams-core';\n\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\n\nconst pathFinderInstance = new PF.JumpPointFinder({\n\theuristic: PF.Heuristic.manhattan,\n\tdiagonalMovement: PF.DiagonalMovement.Never\n});\n\nexport class PathFinding {\n\tinstance: any;\n\tfactory: PathFindingLinkFactory;\n\n\tconstructor(factory: PathFindingLinkFactory) {\n\t\tthis.instance = pathFinderInstance;\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Taking as argument a fully unblocked walking matrix, this method\n\t * finds a direct path from point A to B.\n\t */\n\tcalculateDirectPath(from: PointModel, to: PointModel): number[][] {\n\t\tconst matrix = this.factory.getCanvasMatrix();\n\t\tconst grid = new PF.Grid(matrix);\n\n\t\treturn pathFinderInstance.findPath(\n\t\t\tthis.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tgrid\n\t\t);\n\t}\n\n\t/**\n\t * Using @link{#calculateDirectPath}'s result as input, we here\n\t * determine the first walkable point found in the matrix that includes\n\t * blocked paths.\n\t */\n\tcalculateLinkStartEndCoords(\n\t\tmatrix: number[][],\n\t\tpath: number[][]\n\t): {\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tpathToStart: number[][];\n\t\tpathToEnd: number[][];\n\t} {\n\t\tconst startIndex = path.findIndex((point) => {\n\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\telse return false;\n\t\t});\n\t\tconst endIndex =\n\t\t\tpath.length -\n\t\t\t1 -\n\t\t\tpath\n\t\t\t\t.slice()\n\t\t\t\t.reverse()\n\t\t\t\t.findIndex((point) => {\n\t\t\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\t\t\telse return false;\n\t\t\t\t});\n\n\t\t// are we trying to create a path exclusively through blocked areas?\n\t\t// if so, let's fallback to the linear routing\n\t\tif (startIndex === -1 || endIndex === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst pathToStart = path.slice(0, startIndex);\n\t\tconst pathToEnd = path.slice(endIndex);\n\n\t\treturn {\n\t\t\tstart: {\n\t\t\t\tx: path[startIndex][0],\n\t\t\t\ty: path[startIndex][1]\n\t\t\t},\n\t\t\tend: {\n\t\t\t\tx: path[endIndex][0],\n\t\t\t\ty: path[endIndex][1]\n\t\t\t},\n\t\t\tpathToStart,\n\t\t\tpathToEnd\n\t\t};\n\t}\n\n\t/**\n\t * Puts everything together: merges the paths from/to the centre of the ports,\n\t * with the path calculated around other elements.\n\t */\n\tcalculateDynamicPath(\n\t\troutingMatrix: number[][],\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tpathToStart: number[][],\n\t\tpathToEnd: number[][]\n\t) {\n\t\t// generate the path based on the matrix with obstacles\n\t\tconst grid = new PF.Grid(routingMatrix);\n\t\tconst dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n\n\t\t// aggregate everything to have the calculated path ready for rendering\n\t\tconst pathCoords = pathToStart\n\t\t\t.concat(dynamicPath, pathToEnd)\n\t\t\t.map((coords) => [\n\t\t\t\tthis.factory.translateRoutingX(coords[0], true),\n\t\t\t\tthis.factory.translateRoutingY(coords[1], true)\n\t\t\t]);\n\t\treturn PF.Util.compressPath(pathCoords);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}