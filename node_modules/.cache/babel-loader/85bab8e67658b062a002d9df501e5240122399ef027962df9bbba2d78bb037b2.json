{"ast":null,"code":"/**\r\n * @author imor / https://github.com/imor\r\n */\nvar Heap = require('heap');\nvar Util = require('../core/Util');\nvar Heuristic = require('../core/Heuristic');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\nfunction JumpPointFinderBase(opt) {\n  opt = opt || {};\n  this.heuristic = opt.heuristic || Heuristic.manhattan;\n  this.trackJumpRecursion = opt.trackJumpRecursion || false;\n}\n\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\nJumpPointFinderBase.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var openList = this.openList = new Heap(function (nodeA, nodeB) {\n      return nodeA.f - nodeB.f;\n    }),\n    startNode = this.startNode = grid.getNodeAt(startX, startY),\n    endNode = this.endNode = grid.getNodeAt(endX, endY),\n    node;\n  this.grid = grid;\n\n  // set the `g` and `f` value of the start node to be 0\n  startNode.g = 0;\n  startNode.f = 0;\n\n  // push the start node into the open list\n  openList.push(startNode);\n  startNode.opened = true;\n\n  // while the open list is not empty\n  while (!openList.empty()) {\n    // pop the position of node which has the minimum `f` value.\n    node = openList.pop();\n    node.closed = true;\n    if (node === endNode) {\n      return Util.expandPath(Util.backtrace(endNode));\n    }\n    this._identifySuccessors(node);\n  }\n\n  // fail to find the path\n  return [];\n};\n\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\nJumpPointFinderBase.prototype._identifySuccessors = function (node) {\n  var grid = this.grid,\n    heuristic = this.heuristic,\n    openList = this.openList,\n    endX = this.endNode.x,\n    endY = this.endNode.y,\n    neighbors,\n    neighbor,\n    jumpPoint,\n    i,\n    l,\n    x = node.x,\n    y = node.y,\n    jx,\n    jy,\n    dx,\n    dy,\n    d,\n    ng,\n    jumpNode,\n    abs = Math.abs,\n    max = Math.max;\n  neighbors = this._findNeighbors(node);\n  for (i = 0, l = neighbors.length; i < l; ++i) {\n    neighbor = neighbors[i];\n    jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\n    if (jumpPoint) {\n      jx = jumpPoint[0];\n      jy = jumpPoint[1];\n      jumpNode = grid.getNodeAt(jx, jy);\n      if (jumpNode.closed) {\n        continue;\n      }\n\n      // include distance, as parent may not be immediately adjacent:\n      d = Heuristic.octile(abs(jx - x), abs(jy - y));\n      ng = node.g + d; // next `g` value\n\n      if (!jumpNode.opened || ng < jumpNode.g) {\n        jumpNode.g = ng;\n        jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\n        jumpNode.f = jumpNode.g + jumpNode.h;\n        jumpNode.parent = node;\n        if (!jumpNode.opened) {\n          openList.push(jumpNode);\n          jumpNode.opened = true;\n        } else {\n          openList.updateItem(jumpNode);\n        }\n      }\n    }\n  }\n};\nmodule.exports = JumpPointFinderBase;","map":{"version":3,"names":["Heap","require","Util","Heuristic","DiagonalMovement","JumpPointFinderBase","opt","heuristic","manhattan","trackJumpRecursion","prototype","findPath","startX","startY","endX","endY","grid","openList","nodeA","nodeB","f","startNode","getNodeAt","endNode","node","g","push","opened","empty","pop","closed","expandPath","backtrace","_identifySuccessors","x","y","neighbors","neighbor","jumpPoint","i","l","jx","jy","dx","dy","d","ng","jumpNode","abs","Math","max","_findNeighbors","length","_jump","octile","h","parent","updateItem","module","exports"],"sources":["C:/Users/samir/Diagram gen/diagram-sami/node_modules/pathfinding/src/finders/JumpPointFinderBase.js"],"sourcesContent":["/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}