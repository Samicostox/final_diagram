{"ast":null,"code":"import { Action, InputType } from '../core-actions/Action';\nexport class ZoomCanvasAction extends Action {\n  constructor(options = {}) {\n    super({\n      type: InputType.MOUSE_WHEEL,\n      fire: actionEvent => {\n        const {\n          event\n        } = actionEvent;\n        // we can block layer rendering because we are only targeting the transforms\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(false);\n        }\n        const model = this.engine.getModel();\n        event.stopPropagation();\n        const oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n        let scrollDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\n        //check if it is pinch gesture\n        if (event.ctrlKey && scrollDelta % 1 !== 0) {\n          /*\n              Chrome and Firefox sends wheel event with deltaY that\n              have fractional part, also `ctrlKey` prop of the event is true\n              though ctrl isn't pressed\n          */\n          scrollDelta /= 3;\n        } else {\n          scrollDelta /= 60;\n        }\n        if (model.getZoomLevel() + scrollDelta > 10) {\n          model.setZoomLevel(model.getZoomLevel() + scrollDelta);\n        }\n        const zoomFactor = model.getZoomLevel() / 100;\n        const boundingRect = event.currentTarget.getBoundingClientRect();\n        const clientWidth = boundingRect.width;\n        const clientHeight = boundingRect.height;\n        // compute difference between rect before and after scroll\n        const widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n        const heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n        // compute mouse coords relative to canvas\n        const clientX = event.clientX - boundingRect.left;\n        const clientY = event.clientY - boundingRect.top;\n        // compute width and height increment factor\n        const xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n        const yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n        model.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n        this.engine.repaintCanvas();\n        // re-enable rendering\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(true);\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["Action","InputType","ZoomCanvasAction","constructor","options","type","MOUSE_WHEEL","fire","actionEvent","event","layer","engine","getModel","getLayers","allowRepaint","model","stopPropagation","oldZoomFactor","getZoomLevel","scrollDelta","inverseZoom","deltaY","ctrlKey","setZoomLevel","zoomFactor","boundingRect","currentTarget","getBoundingClientRect","clientWidth","width","clientHeight","height","widthDiff","heightDiff","clientX","left","clientY","top","xFactor","getOffsetX","yFactor","getOffsetY","setOffset","repaintCanvas"],"sources":["C:\\Users\\samir\\Diagram gen\\diagram-sami\\node_modules\\@projectstorm\\react-canvas-core\\src\\actions\\ZoomCanvasAction.ts"],"sourcesContent":["import { WheelEvent } from 'react';\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\n\nexport interface ZoomCanvasActionOptions {\n\tinverseZoom?: boolean;\n}\n\nexport class ZoomCanvasAction extends Action {\n\tconstructor(options: ZoomCanvasActionOptions = {}) {\n\t\tsuper({\n\t\t\ttype: InputType.MOUSE_WHEEL,\n\t\t\tfire: (actionEvent: ActionEvent<WheelEvent>) => {\n\t\t\t\tconst { event } = actionEvent;\n\t\t\t\t// we can block layer rendering because we are only targeting the transforms\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\n\t\t\t\t\tlayer.allowRepaint(false);\n\t\t\t\t}\n\n\t\t\t\tconst model = this.engine.getModel();\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tconst oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n\t\t\t\tlet scrollDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\n\t\t\t\t//check if it is pinch gesture\n\t\t\t\tif (event.ctrlKey && scrollDelta % 1 !== 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tChrome and Firefox sends wheel event with deltaY that\n\t\t\t\t\t\thave fractional part, also `ctrlKey` prop of the event is true\n\t\t\t\t\t\tthough ctrl isn't pressed\n\t\t\t\t\t*/\n\t\t\t\t\tscrollDelta /= 3;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDelta /= 60;\n\t\t\t\t}\n\t\t\t\tif (model.getZoomLevel() + scrollDelta > 10) {\n\t\t\t\t\tmodel.setZoomLevel(model.getZoomLevel() + scrollDelta);\n\t\t\t\t}\n\n\t\t\t\tconst zoomFactor = model.getZoomLevel() / 100;\n\n\t\t\t\tconst boundingRect = event.currentTarget.getBoundingClientRect();\n\t\t\t\tconst clientWidth = boundingRect.width;\n\t\t\t\tconst clientHeight = boundingRect.height;\n\t\t\t\t// compute difference between rect before and after scroll\n\t\t\t\tconst widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n\t\t\t\tconst heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n\t\t\t\t// compute mouse coords relative to canvas\n\t\t\t\tconst clientX = event.clientX - boundingRect.left;\n\t\t\t\tconst clientY = event.clientY - boundingRect.top;\n\n\t\t\t\t// compute width and height increment factor\n\t\t\t\tconst xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n\t\t\t\tconst yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n\n\t\t\t\tmodel.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n\t\t\t\tthis.engine.repaintCanvas();\n\n\t\t\t\t// re-enable rendering\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\n\t\t\t\t\tlayer.allowRepaint(true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n"],"mappings":"AACA,SAASA,MAAM,EAAeC,SAAS,QAAQ,wBAAwB;AAMvE,OAAM,MAAOC,gBAAiB,SAAQF,MAAM;EAC3CG,YAAYC,OAAA,GAAmC,EAAE;IAChD,KAAK,CAAC;MACLC,IAAI,EAAEJ,SAAS,CAACK,WAAW;MAC3BC,IAAI,EAAGC,WAAoC,IAAI;QAC9C,MAAM;UAAEC;QAAK,CAAE,GAAGD,WAAW;QAC7B;QACA,KAAK,IAAIE,KAAK,IAAI,IAAI,CAACC,MAAM,CAACC,QAAQ,EAAE,CAACC,SAAS,EAAE,EAAE;UACrDH,KAAK,CAACI,YAAY,CAAC,KAAK,CAAC;;QAG1B,MAAMC,KAAK,GAAG,IAAI,CAACJ,MAAM,CAACC,QAAQ,EAAE;QACpCH,KAAK,CAACO,eAAe,EAAE;QACvB,MAAMC,aAAa,GAAG,IAAI,CAACN,MAAM,CAACC,QAAQ,EAAE,CAACM,YAAY,EAAE,GAAG,GAAG;QACjE,IAAIC,WAAW,GAAGf,OAAO,CAACgB,WAAW,GAAG,CAACX,KAAK,CAACY,MAAM,GAAGZ,KAAK,CAACY,MAAM;QACpE;QACA,IAAIZ,KAAK,CAACa,OAAO,IAAIH,WAAW,GAAG,CAAC,KAAK,CAAC,EAAE;UAC3C;;;;;UAKAA,WAAW,IAAI,CAAC;SAChB,MAAM;UACNA,WAAW,IAAI,EAAE;;QAElB,IAAIJ,KAAK,CAACG,YAAY,EAAE,GAAGC,WAAW,GAAG,EAAE,EAAE;UAC5CJ,KAAK,CAACQ,YAAY,CAACR,KAAK,CAACG,YAAY,EAAE,GAAGC,WAAW,CAAC;;QAGvD,MAAMK,UAAU,GAAGT,KAAK,CAACG,YAAY,EAAE,GAAG,GAAG;QAE7C,MAAMO,YAAY,GAAGhB,KAAK,CAACiB,aAAa,CAACC,qBAAqB,EAAE;QAChE,MAAMC,WAAW,GAAGH,YAAY,CAACI,KAAK;QACtC,MAAMC,YAAY,GAAGL,YAAY,CAACM,MAAM;QACxC;QACA,MAAMC,SAAS,GAAGJ,WAAW,GAAGJ,UAAU,GAAGI,WAAW,GAAGX,aAAa;QACxE,MAAMgB,UAAU,GAAGH,YAAY,GAAGN,UAAU,GAAGM,YAAY,GAAGb,aAAa;QAC3E;QACA,MAAMiB,OAAO,GAAGzB,KAAK,CAACyB,OAAO,GAAGT,YAAY,CAACU,IAAI;QACjD,MAAMC,OAAO,GAAG3B,KAAK,CAAC2B,OAAO,GAAGX,YAAY,CAACY,GAAG;QAEhD;QACA,MAAMC,OAAO,GAAG,CAACJ,OAAO,GAAGnB,KAAK,CAACwB,UAAU,EAAE,IAAItB,aAAa,GAAGW,WAAW;QAC5E,MAAMY,OAAO,GAAG,CAACJ,OAAO,GAAGrB,KAAK,CAAC0B,UAAU,EAAE,IAAIxB,aAAa,GAAGa,YAAY;QAE7Ef,KAAK,CAAC2B,SAAS,CAAC3B,KAAK,CAACwB,UAAU,EAAE,GAAGP,SAAS,GAAGM,OAAO,EAAEvB,KAAK,CAAC0B,UAAU,EAAE,GAAGR,UAAU,GAAGO,OAAO,CAAC;QACpG,IAAI,CAAC7B,MAAM,CAACgC,aAAa,EAAE;QAE3B;QACA,KAAK,IAAIjC,KAAK,IAAI,IAAI,CAACC,MAAM,CAACC,QAAQ,EAAE,CAACC,SAAS,EAAE,EAAE;UACrDH,KAAK,CAACI,YAAY,CAAC,IAAI,CAAC;;MAE1B;KACA,CAAC;EACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}