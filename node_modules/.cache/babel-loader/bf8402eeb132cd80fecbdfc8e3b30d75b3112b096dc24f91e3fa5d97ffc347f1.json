{"ast":null,"code":"import * as React from 'react';\nimport { LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nexport class RightAngleLinkWidget extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMove = function (event) {\n      this.draggingEvent(event, this.dragging_index);\n    }.bind(this);\n    this.handleUp = function (event) {\n      // Unregister handlers to avoid multiple event handlers for other links\n      this.setState({\n        canDrag: false,\n        selected: false\n      });\n      window.removeEventListener('mousemove', this.handleMove);\n      window.removeEventListener('mouseup', this.handleUp);\n    }.bind(this);\n    this.refPaths = [];\n    this.state = {\n      selected: false,\n      canDrag: false\n    };\n    this.dragging_index = 0;\n  }\n  componentDidUpdate() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n  componentDidMount() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n  componentWillUnmount() {\n    this.props.link.setRenderedPaths([]);\n  }\n  generateLink(path, extraProps, id) {\n    const ref = React.createRef();\n    this.refPaths.push(ref);\n    return React.createElement(DefaultLinkSegmentWidget, {\n      key: `link-${id}`,\n      path: path,\n      selected: this.state.selected,\n      diagramEngine: this.props.diagramEngine,\n      factory: this.props.diagramEngine.getFactoryForLink(this.props.link),\n      link: this.props.link,\n      forwardRef: ref,\n      onSelection: selected => {\n        this.setState({\n          selected: selected\n        });\n      },\n      extras: extraProps\n    });\n  }\n  calculatePositions(points, event, index, coordinate) {\n    // If path is first or last add another point to keep node port on its position\n    if (index === 0) {\n      let point = new PointModel({\n        link: this.props.link,\n        position: new Point(points[index].getX(), points[index].getY())\n      });\n      this.props.link.addPoint(point, index);\n      this.dragging_index++;\n      return;\n    } else if (index === points.length - 2) {\n      let point = new PointModel({\n        link: this.props.link,\n        position: new Point(points[index + 1].getX(), points[index + 1].getY())\n      });\n      this.props.link.addPoint(point, index + 1);\n      return;\n    }\n    // Merge two points if it is not close to node port and close to each other\n    if (index - 2 > 0) {\n      let _points = {\n        [index - 2]: points[index - 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index - 1]: points[index - 1].getPosition()\n      };\n      if (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n        _points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        points[index - 2].setPosition(_points[index - 2]);\n        points[index + 1].setPosition(_points[index + 1]);\n        points[index - 1].remove();\n        points[index - 1].remove();\n        this.dragging_index--;\n        this.dragging_index--;\n        return;\n      }\n    }\n    // Merge two points if it is not close to node port\n    if (index + 2 < points.length - 2) {\n      let _points = {\n        [index + 3]: points[index + 3].getPosition(),\n        [index + 2]: points[index + 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index]: points[index].getPosition()\n      };\n      if (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n        _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        _points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        points[index].setPosition(_points[index]);\n        points[index + 3].setPosition(_points[index + 3]);\n        points[index + 1].remove();\n        points[index + 1].remove();\n        return;\n      }\n    }\n    // If no condition above handled then just update path points position\n    let _points = {\n      [index]: points[index].getPosition(),\n      [index + 1]: points[index + 1].getPosition()\n    };\n    _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n    _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n    points[index].setPosition(_points[index]);\n    points[index + 1].setPosition(_points[index + 1]);\n  }\n  draggingEvent(event, index) {\n    let points = this.props.link.getPoints();\n    // get moving difference. Index + 1 will work because links indexes has\n    // length = points.lenght - 1\n    let dx = Math.abs(points[index].getX() - points[index + 1].getX());\n    let dy = Math.abs(points[index].getY() - points[index + 1].getY());\n    // moving with y direction\n    if (dx === 0) {\n      this.calculatePositions(points, event, index, 'x');\n    } else if (dy === 0) {\n      this.calculatePositions(points, event, index, 'y');\n    }\n    this.props.link.setFirstAndLastPathsDirection();\n  }\n  render() {\n    //ensure id is present for all points on the path\n    let points = this.props.link.getPoints();\n    let paths = [];\n    // Get points based on link orientation\n    let pointLeft = points[0];\n    let pointRight = points[points.length - 1];\n    let hadToSwitch = false;\n    if (pointLeft.getX() > pointRight.getX()) {\n      pointLeft = points[points.length - 1];\n      pointRight = points[0];\n      hadToSwitch = true;\n    }\n    let dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\n    // When new link add one middle point to get everywhere 90° angle\n    if (this.props.link.getTargetPort() === null && points.length === 2) {\n      [...Array(2)].forEach(item => {\n        this.props.link.addPoint(new PointModel({\n          link: this.props.link,\n          position: new Point(pointLeft.getX(), pointRight.getY())\n        }), 1);\n      });\n      this.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n    }\n    // When new link is moving and not connected to target port move with middle point\n    // TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n    //  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n    else if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n      points[1].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointLeft.getY() : pointRight.getY());\n      points[2].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointRight.getY() : pointLeft.getY());\n    }\n    // Render was called but link is not moved but user.\n    // Node is moved and in this case fix coordinates to get 90° angle.\n    // For loop just for first and last path\n    else if (!this.state.canDrag && points.length > 2) {\n      // Those points and its position only will be moved\n      for (let i = 1; i < points.length; i += points.length - 2) {\n        if (i - 1 === 0) {\n          if (this.props.link.getFirstPathXdirection()) {\n            points[i].setPosition(points[i].getX(), points[i - 1].getY());\n          } else {\n            points[i].setPosition(points[i - 1].getX(), points[i].getY());\n          }\n        } else {\n          if (this.props.link.getLastPathXdirection()) {\n            points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n          } else {\n            points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n          }\n        }\n      }\n    }\n    // If there is existing link which has two points add one\n    // NOTE: It doesn't matter if check is for dy or dx\n    if (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n      this.props.link.addPoint(new PointModel({\n        link: this.props.link,\n        position: new Point(pointLeft.getX(), pointRight.getY())\n      }));\n    }\n    for (let j = 0; j < points.length - 1; j++) {\n      paths.push(this.generateLink(LinkWidget.generateLinePath(points[j], points[j + 1]), {\n        'data-linkid': this.props.link.getID(),\n        'data-point': j,\n        onMouseDown: event => {\n          if (event.button === 0) {\n            this.setState({\n              canDrag: true\n            });\n            this.dragging_index = j;\n            // Register mouse move event to track mouse position\n            // On mouse up these events are unregistered check \"this.handleUp\"\n            window.addEventListener('mousemove', this.handleMove);\n            window.addEventListener('mouseup', this.handleUp);\n          }\n        },\n        onMouseEnter: event => {\n          this.setState({\n            selected: true\n          });\n          this.props.link.lastHoverIndexOfPath = j;\n        }\n      }, j));\n    }\n    this.refPaths = [];\n    return React.createElement(\"g\", {\n      \"data-default-link-test\": this.props.link.getOptions().testName\n    }, paths);\n  }\n}\nRightAngleLinkWidget.defaultProps = {\n  color: 'red',\n  width: 3,\n  link: null,\n  smooth: false,\n  diagramEngine: null,\n  factory: null\n};","map":{"version":3,"names":["React","LinkWidget","PointModel","DefaultLinkSegmentWidget","Point","RightAngleLinkWidget","Component","constructor","props","handleMove","event","draggingEvent","dragging_index","bind","handleUp","setState","canDrag","selected","window","removeEventListener","refPaths","state","componentDidUpdate","link","setRenderedPaths","map","ref","current","componentDidMount","componentWillUnmount","generateLink","path","extraProps","id","createRef","push","createElement","key","diagramEngine","factory","getFactoryForLink","forwardRef","onSelection","extras","calculatePositions","points","index","coordinate","point","position","getX","getY","addPoint","length","_points","getPosition","Math","abs","getRelativeMousePoint","setPosition","remove","getPoints","dx","dy","setFirstAndLastPathsDirection","render","paths","pointLeft","pointRight","hadToSwitch","getTargetPort","Array","forEach","item","setManuallyFirstAndLastPathsDirection","getSourcePort","i","getFirstPathXdirection","getLastPathXdirection","j","generateLinePath","getID","onMouseDown","button","addEventListener","onMouseEnter","lastHoverIndexOfPath","getOptions","testName","defaultProps","color","width","smooth"],"sources":["C:\\Users\\samir\\Diagram gen\\diagram-sami\\node_modules\\@projectstorm\\react-diagrams-routing\\src\\link\\RightAngleLinkWidget.tsx"],"sourcesContent":["import * as React from 'react';\nimport { DiagramEngine, LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\nimport { DefaultLinkModel, DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nimport { MouseEvent } from 'react';\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\n\nexport interface RightAngleLinkProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: RightAngleLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: RightAngleLinkFactory;\n}\n\nexport interface RightAngleLinkState {\n\tselected: boolean;\n\tcanDrag: boolean;\n}\n\nexport class RightAngleLinkWidget extends React.Component<RightAngleLinkProps, RightAngleLinkState> {\n\tpublic static defaultProps: RightAngleLinkProps = {\n\t\tcolor: 'red',\n\t\twidth: 3,\n\t\tlink: null,\n\t\tsmooth: false,\n\t\tdiagramEngine: null,\n\t\tfactory: null\n\t};\n\n\trefPaths: React.RefObject<SVGPathElement>[];\n\n\t// DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n\trefLabels: { [id: string]: HTMLElement };\n\tdragging_index: number;\n\n\tconstructor(props: RightAngleLinkProps) {\n\t\tsuper(props);\n\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false,\n\t\t\tcanDrag: false\n\t\t};\n\n\t\tthis.dragging_index = 0;\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={extraProps}\n\t\t\t/>\n\t\t);\n\t}\n\n\tcalculatePositions(points: PointModel[], event: MouseEvent, index: number, coordinate: string) {\n\t\t// If path is first or last add another point to keep node port on its position\n\t\tif (index === 0) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index].getX(), points[index].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index);\n\t\t\tthis.dragging_index++;\n\t\t\treturn;\n\t\t} else if (index === points.length - 2) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index + 1].getX(), points[index + 1].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index + 1);\n\t\t\treturn;\n\t\t}\n\n\t\t// Merge two points if it is not close to node port and close to each other\n\t\tif (index - 2 > 0) {\n\t\t\tlet _points = {\n\t\t\t\t[index - 2]: points[index - 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index - 1]: points[index - 1].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n\t\t\t\t_points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index - 2].setPosition(_points[index - 2]);\n\t\t\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tthis.dragging_index--;\n\t\t\t\tthis.dragging_index--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Merge two points if it is not close to node port\n\t\tif (index + 2 < points.length - 2) {\n\t\t\tlet _points = {\n\t\t\t\t[index + 3]: points[index + 3].getPosition(),\n\t\t\t\t[index + 2]: points[index + 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index]: points[index].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n\t\t\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index].setPosition(_points[index]);\n\t\t\t\tpoints[index + 3].setPosition(_points[index + 3]);\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If no condition above handled then just update path points position\n\t\tlet _points = {\n\t\t\t[index]: points[index].getPosition(),\n\t\t\t[index + 1]: points[index + 1].getPosition()\n\t\t};\n\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\tpoints[index].setPosition(_points[index]);\n\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t}\n\n\tdraggingEvent(event: MouseEvent, index: number) {\n\t\tlet points = this.props.link.getPoints();\n\t\t// get moving difference. Index + 1 will work because links indexes has\n\t\t// length = points.lenght - 1\n\t\tlet dx = Math.abs(points[index].getX() - points[index + 1].getX());\n\t\tlet dy = Math.abs(points[index].getY() - points[index + 1].getY());\n\n\t\t// moving with y direction\n\t\tif (dx === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'x');\n\t\t} else if (dy === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'y');\n\t\t}\n\t\tthis.props.link.setFirstAndLastPathsDirection();\n\t}\n\n\thandleMove = function (event: MouseEvent) {\n\t\tthis.draggingEvent(event, this.dragging_index);\n\t}.bind(this);\n\n\thandleUp = function (event: MouseEvent) {\n\t\t// Unregister handlers to avoid multiple event handlers for other links\n\t\tthis.setState({ canDrag: false, selected: false });\n\t\twindow.removeEventListener('mousemove', this.handleMove);\n\t\twindow.removeEventListener('mouseup', this.handleUp);\n\t}.bind(this);\n\n\trender() {\n\t\t//ensure id is present for all points on the path\n\t\tlet points = this.props.link.getPoints();\n\t\tlet paths = [];\n\n\t\t// Get points based on link orientation\n\t\tlet pointLeft = points[0];\n\t\tlet pointRight = points[points.length - 1];\n\t\tlet hadToSwitch = false;\n\t\tif (pointLeft.getX() > pointRight.getX()) {\n\t\t\tpointLeft = points[points.length - 1];\n\t\t\tpointRight = points[0];\n\t\t\thadToSwitch = true;\n\t\t}\n\t\tlet dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\n\n\t\t// When new link add one middle point to get everywhere 90° angle\n\t\tif (this.props.link.getTargetPort() === null && points.length === 2) {\n\t\t\t[...Array(2)].forEach((item) => {\n\t\t\t\tthis.props.link.addPoint(\n\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t\t}),\n\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t});\n\t\t\tthis.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n\t\t}\n\t\t// When new link is moving and not connected to target port move with middle point\n\t\t// TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n\t\t//  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n\t\telse if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n\t\t\tpoints[1].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointLeft.getY() : pointRight.getY()\n\t\t\t);\n\t\t\tpoints[2].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointRight.getY() : pointLeft.getY()\n\t\t\t);\n\t\t}\n\t\t// Render was called but link is not moved but user.\n\t\t// Node is moved and in this case fix coordinates to get 90° angle.\n\t\t// For loop just for first and last path\n\t\telse if (!this.state.canDrag && points.length > 2) {\n\t\t\t// Those points and its position only will be moved\n\t\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\n\t\t\t\tif (i - 1 === 0) {\n\t\t\t\t\tif (this.props.link.getFirstPathXdirection()) {\n\t\t\t\t\t\tpoints[i].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.props.link.getLastPathXdirection()) {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If there is existing link which has two points add one\n\t\t// NOTE: It doesn't matter if check is for dy or dx\n\t\tif (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n\t\t\tthis.props.link.addPoint(\n\t\t\t\tnew PointModel({\n\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\tpaths.push(\n\t\t\t\tthis.generateLink(\n\t\t\t\t\tLinkWidget.generateLinePath(points[j], points[j + 1]),\n\t\t\t\t\t{\n\t\t\t\t\t\t'data-linkid': this.props.link.getID(),\n\t\t\t\t\t\t'data-point': j,\n\t\t\t\t\t\tonMouseDown: (event: MouseEvent) => {\n\t\t\t\t\t\t\tif (event.button === 0) {\n\t\t\t\t\t\t\t\tthis.setState({ canDrag: true });\n\t\t\t\t\t\t\t\tthis.dragging_index = j;\n\t\t\t\t\t\t\t\t// Register mouse move event to track mouse position\n\t\t\t\t\t\t\t\t// On mouse up these events are unregistered check \"this.handleUp\"\n\t\t\t\t\t\t\t\twindow.addEventListener('mousemove', this.handleMove);\n\t\t\t\t\t\t\t\twindow.addEventListener('mouseup', this.handleUp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonMouseEnter: (event: MouseEvent) => {\n\t\t\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t\t\t\tthis.props.link.lastHoverIndexOfPath = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tj\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tthis.refPaths = [];\n\t\treturn <g data-default-link-test={this.props.link.getOptions().testName}>{paths}</g>;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}