{"ast":null,"code":"var Util = require('../core/Util');\nvar Heuristic = require('../core/Heuristic');\nvar Node = require('../core/Node');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\nfunction IDAStarFinder(opt) {\n  opt = opt || {};\n  this.allowDiagonal = opt.allowDiagonal;\n  this.dontCrossCorners = opt.dontCrossCorners;\n  this.diagonalMovement = opt.diagonalMovement;\n  this.heuristic = opt.heuristic || Heuristic.manhattan;\n  this.weight = opt.weight || 1;\n  this.trackRecursion = opt.trackRecursion || false;\n  this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\n\n  if (!this.diagonalMovement) {\n    if (!this.allowDiagonal) {\n      this.diagonalMovement = DiagonalMovement.Never;\n    } else {\n      if (this.dontCrossCorners) {\n        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n      } else {\n        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n      }\n    }\n  }\n\n  // When diagonal movement is allowed the manhattan heuristic is not\n  // admissible, it should be octile instead\n  if (this.diagonalMovement === DiagonalMovement.Never) {\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n  } else {\n    this.heuristic = opt.heuristic || Heuristic.octile;\n  }\n}\n\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\nIDAStarFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  // Used for statistics:\n  var nodesVisited = 0;\n\n  // Execution time limitation:\n  var startTime = new Date().getTime();\n\n  // Heuristic helper:\n  var h = function (a, b) {\n    return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\n  }.bind(this);\n\n  // Step cost from a to b:\n  var cost = function (a, b) {\n    return a.x === b.x || a.y === b.y ? 1 : Math.SQRT2;\n  };\n\n  /**\r\n   * IDA* search implementation.\r\n   *\r\n   * @param {Node} The node currently expanding from.\r\n   * @param {number} Cost to reach the given node.\r\n   * @param {number} Maximum search depth (cut-off value).\r\n   * @param {Array<Array<number>>} The found route.\r\n   * @param {number} Recursion depth.\r\n   *\r\n   * @return {Object} either a number with the new optimal cut-off depth,\r\n   * or a valid node instance, in which case a path was found.\r\n   */\n  var search = function (node, g, cutoff, route, depth) {\n    nodesVisited++;\n\n    // Enforce timelimit:\n    if (this.timeLimit > 0 && new Date().getTime() - startTime > this.timeLimit * 1000) {\n      // Enforced as \"path-not-found\".\n      return Infinity;\n    }\n    var f = g + h(node, end) * this.weight;\n\n    // We've searched too deep for this iteration.\n    if (f > cutoff) {\n      return f;\n    }\n    if (node == end) {\n      route[depth] = [node.x, node.y];\n      return node;\n    }\n    var min, t, k, neighbour;\n    var neighbours = grid.getNeighbors(node, this.diagonalMovement);\n\n    // Sort the neighbours, gives nicer paths. But, this deviates\n    // from the original algorithm - so I left it out.\n    //neighbours.sort(function(a, b){\n    //    return h(a, end) - h(b, end);\n    //});\n\n    /*jshint -W084 */ //Disable warning: Expected a conditional expression and instead saw an assignment\n    for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\n      /*jshint +W084 */ //Enable warning: Expected a conditional expression and instead saw an assignment\n      if (this.trackRecursion) {\n        // Retain a copy for visualisation. Due to recursion, this\n        // node may be part of other paths too.\n        neighbour.retainCount = neighbour.retainCount + 1 || 1;\n        if (neighbour.tested !== true) {\n          neighbour.tested = true;\n        }\n      }\n      t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\n      if (t instanceof Node) {\n        route[depth] = [node.x, node.y];\n\n        // For a typical A* linked list, this would work:\n        // neighbour.parent = node;\n        return t;\n      }\n\n      // Decrement count, then determine whether it's actually closed.\n      if (this.trackRecursion && --neighbour.retainCount === 0) {\n        neighbour.tested = false;\n      }\n      if (t < min) {\n        min = t;\n      }\n    }\n    return min;\n  }.bind(this);\n\n  // Node instance lookups:\n  var start = grid.getNodeAt(startX, startY);\n  var end = grid.getNodeAt(endX, endY);\n\n  // Initial search depth, given the typical heuristic contraints,\n  // there should be no cheaper route possible.\n  var cutOff = h(start, end);\n  var j, route, t;\n\n  // With an overflow protection.\n  for (j = 0; true; ++j) {\n    route = [];\n\n    // Search till cut-off depth:\n    t = search(start, 0, cutOff, route, 0);\n\n    // Route not possible, or not found in time limit.\n    if (t === Infinity) {\n      return [];\n    }\n\n    // If t is a node, it's also the end node. Route is now\n    // populated with a valid path to the end node.\n    if (t instanceof Node) {\n      return route;\n    }\n\n    // Try again, this time with a deeper cut-off. The t score\n    // is the closest we got to the end node.\n    cutOff = t;\n  }\n\n  // This _should_ never to be reached.\n  return [];\n};\nmodule.exports = IDAStarFinder;","map":{"version":3,"names":["Util","require","Heuristic","Node","DiagonalMovement","IDAStarFinder","opt","allowDiagonal","dontCrossCorners","diagonalMovement","heuristic","manhattan","weight","trackRecursion","timeLimit","Infinity","Never","OnlyWhenNoObstacles","IfAtMostOneObstacle","octile","prototype","findPath","startX","startY","endX","endY","grid","nodesVisited","startTime","Date","getTime","h","a","b","Math","abs","x","y","bind","cost","SQRT2","search","node","g","cutoff","route","depth","f","end","min","t","k","neighbour","neighbours","getNeighbors","retainCount","tested","start","getNodeAt","cutOff","j","module","exports"],"sources":["C:/Users/samir/Diagram gen/diagram-sami/node_modules/pathfinding/src/finders/IDAStarFinder.js"],"sourcesContent":["var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}