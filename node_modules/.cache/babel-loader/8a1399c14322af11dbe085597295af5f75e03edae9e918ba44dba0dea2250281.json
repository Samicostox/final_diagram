{"ast":null,"code":"import * as React from 'react';\nimport * as _ from 'lodash';\nimport { PathFinding } from '../engine/PathFinding';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nexport class PathFindingLinkWidget extends React.Component {\n  constructor(props) {\n    super(props);\n    this.refPaths = [];\n    this.state = {\n      selected: false\n    };\n    this.pathFinding = new PathFinding(this.props.factory);\n  }\n  componentDidUpdate() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n  componentDidMount() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n  componentWillUnmount() {\n    this.props.link.setRenderedPaths([]);\n  }\n  generateLink(path, id) {\n    const ref = React.createRef();\n    this.refPaths.push(ref);\n    return React.createElement(DefaultLinkSegmentWidget, {\n      key: `link-${id}`,\n      path: path,\n      selected: this.state.selected,\n      diagramEngine: this.props.diagramEngine,\n      factory: this.props.diagramEngine.getFactoryForLink(this.props.link),\n      link: this.props.link,\n      forwardRef: ref,\n      onSelection: selected => {\n        this.setState({\n          selected: selected\n        });\n      },\n      extras: {}\n    });\n  }\n  render() {\n    this.refPaths = [];\n    //ensure id is present for all points on the path\n    var points = this.props.link.getPoints();\n    var paths = [];\n    // first step: calculate a direct path between the points being linked\n    const directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n    const routingMatrix = this.props.factory.getRoutingMatrix();\n    // now we need to extract, from the routing matrix, the very first walkable points\n    // so they can be used as origin and destination of the link to be created\n    const smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n    if (smartLink) {\n      const {\n        start,\n        end,\n        pathToStart,\n        pathToEnd\n      } = smartLink;\n      // second step: calculate a path avoiding hitting other elements\n      const simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n      paths.push(\n      //smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n      this.generateLink(this.props.factory.generateDynamicPath(simplifiedPath), '0'));\n    }\n    return React.createElement(React.Fragment, null, paths);\n  }\n}","map":{"version":3,"names":["React","_","PathFinding","DefaultLinkSegmentWidget","PathFindingLinkWidget","Component","constructor","props","refPaths","state","selected","pathFinding","factory","componentDidUpdate","link","setRenderedPaths","map","ref","current","componentDidMount","componentWillUnmount","generateLink","path","id","createRef","push","createElement","key","diagramEngine","getFactoryForLink","forwardRef","onSelection","setState","extras","render","points","getPoints","paths","directPathCoords","calculateDirectPath","first","last","routingMatrix","getRoutingMatrix","smartLink","calculateLinkStartEndCoords","start","end","pathToStart","pathToEnd","simplifiedPath","calculateDynamicPath","generateDynamicPath","Fragment"],"sources":["C:\\Users\\samir\\Diagram gen\\diagram-sami\\node_modules\\@projectstorm\\react-diagrams-routing\\src\\link\\PathFindingLinkWidget.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as _ from 'lodash';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { PathFinding } from '../engine/PathFinding';\nimport { PathFindingLinkFactory } from './PathFindingLinkFactory';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\n\nexport interface PathFindingLinkWidgetProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: PathFindingLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: PathFindingLinkFactory;\n}\n\nexport interface PathFindingLinkWidgetState {\n\tselected: boolean;\n}\n\nexport class PathFindingLinkWidget extends React.Component<PathFindingLinkWidgetProps, PathFindingLinkWidgetState> {\n\trefPaths: React.RefObject<SVGPathElement>[];\n\tpathFinding: PathFinding;\n\n\tconstructor(props: PathFindingLinkWidgetProps) {\n\t\tsuper(props);\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\t\tthis.pathFinding = new PathFinding(this.props.factory);\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={{}}\n\t\t\t/>\n\t\t);\n\t}\n\n\trender() {\n\t\tthis.refPaths = [];\n\t\t//ensure id is present for all points on the path\n\t\tvar points = this.props.link.getPoints();\n\t\tvar paths = [];\n\n\t\t// first step: calculate a direct path between the points being linked\n\t\tconst directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n\n\t\tconst routingMatrix = this.props.factory.getRoutingMatrix();\n\t\t// now we need to extract, from the routing matrix, the very first walkable points\n\t\t// so they can be used as origin and destination of the link to be created\n\t\tconst smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\t\tif (smartLink) {\n\t\t\tconst { start, end, pathToStart, pathToEnd } = smartLink;\n\n\t\t\t// second step: calculate a path avoiding hitting other elements\n\t\t\tconst simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n\n\t\t\tpaths.push(\n\t\t\t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n\t\t\t\tthis.generateLink(this.props.factory.generateDynamicPath(simplifiedPath), '0')\n\t\t\t);\n\t\t}\n\t\treturn <>{paths}</>;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}