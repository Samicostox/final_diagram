{"ast":null,"code":"import { PointModel } from '@projectstorm/react-diagrams-core';\nimport * as dagre from 'dagre';\nimport * as _ from 'lodash';\nimport { Point } from '@projectstorm/geometry';\nexport class DagreEngine {\n  constructor(options = {}) {\n    this.options = options;\n  }\n  redistribute(model) {\n    // Create a new directed graph\n    var g = new dagre.graphlib.Graph({\n      multigraph: true,\n      compound: true\n    });\n    g.setGraph(this.options.graph || {});\n    g.setDefaultEdgeLabel(function () {\n      return {};\n    });\n    // set nodes\n    _.forEach(model.getNodes(), node => {\n      g.setNode(node.getID(), {\n        width: node.width,\n        height: node.height\n      });\n    });\n    _.forEach(model.getLinks(), link => {\n      // set edges\n      if (link.getSourcePort() && link.getTargetPort()) {\n        g.setEdge({\n          v: link.getSourcePort().getNode().getID(),\n          w: link.getTargetPort().getNode().getID(),\n          name: link.getID()\n        });\n      }\n    });\n    // layout the graph\n    dagre.layout(g);\n    g.nodes().forEach(v => {\n      const node = g.node(v);\n      model.getNode(v).setPosition(node.x - node.width / 2, node.y - node.height / 2);\n    });\n    // also include links?\n    if (this.options.includeLinks) {\n      g.edges().forEach(e => {\n        const edge = g.edge(e);\n        const link = model.getLink(e.name);\n        const points = [link.getFirstPoint()];\n        for (let i = 1; i < edge.points.length - 1; i++) {\n          points.push(new PointModel({\n            link: link,\n            position: new Point(edge.points[i].x, edge.points[i].y)\n          }));\n        }\n        link.setPoints(points.concat(link.getLastPoint()));\n      });\n    }\n  }\n  /**\n   * TODO cleanup this method into smaller methods\n   */\n  refreshLinks(diagram) {\n    const {\n      nodeMargin\n    } = this.options;\n    const nodes = diagram.getNodes();\n    const links = diagram.getLinks();\n    let maxChunkRowIndex = -1;\n    // build the chunk matrix\n    const chunks = {}; // true: occupied, false: blank\n    const NodeXColumnIndexDictionary = {};\n    let verticalLines = [];\n    _.forEach(nodes, node => {\n      // find vertical lines. vertical lines go through maximum number of nodes located under each other.\n      const nodeColumnCenter = node.getX() + node.width / 2;\n      if (_.every(verticalLines, vLine => {\n        return Math.abs(nodeColumnCenter - vLine) > nodeMargin;\n      })) {\n        verticalLines.push(nodeColumnCenter);\n      }\n    });\n    // sort chunk columns\n    verticalLines = verticalLines.sort((a, b) => a - b);\n    _.forEach(verticalLines, (line, index) => {\n      chunks[index] = {};\n      chunks[index + 0.5] = {};\n    });\n    // set occupied chunks\n    _.forEach(nodes, node => {\n      const nodeColumnCenter = node.getX() + node.width / 2;\n      const startChunkIndex = Math.floor(node.getY() / nodeMargin);\n      const endChunkIndex = Math.floor((node.getY() + node.height) / nodeMargin);\n      // find max ChunkRowIndex\n      if (endChunkIndex > maxChunkRowIndex) maxChunkRowIndex = endChunkIndex;\n      const nodeColumnIndex = _.findIndex(verticalLines, vLine => {\n        return Math.abs(nodeColumnCenter - vLine) <= nodeMargin;\n      });\n      _.forEach(_.range(startChunkIndex, endChunkIndex + 1), chunkIndex => {\n        chunks[nodeColumnIndex][chunkIndex] = true;\n      });\n      NodeXColumnIndexDictionary[node.getX()] = nodeColumnIndex;\n    });\n    // sort links based on their distances\n    const edges = _.map(links, link => {\n      if (link.getSourcePort() && link.getTargetPort()) {\n        const source = link.getSourcePort().getNode();\n        const target = link.getTargetPort().getNode();\n        const sourceIndex = NodeXColumnIndexDictionary[source.getX()];\n        const targetIndex = NodeXColumnIndexDictionary[target.getX()];\n        return sourceIndex > targetIndex ? {\n          link,\n          sourceIndex,\n          sourceY: source.getY() + source.height / 2,\n          source,\n          targetIndex,\n          targetY: target.getY() + source.height / 2,\n          target\n        } : {\n          link,\n          sourceIndex: targetIndex,\n          sourceY: target.getY() + target.height / 2,\n          source: target,\n          targetIndex: sourceIndex,\n          targetY: source.getY() + source.height / 2,\n          target: source\n        };\n      }\n    });\n    const sortedEdges = _.sortBy(edges, link => {\n      return Math.abs(link.targetIndex - link.sourceIndex);\n    });\n    // set link points\n    if (this.options.includeLinks) {\n      _.forEach(sortedEdges, edge => {\n        const link = diagram.getLink(edge.link.getID());\n        // re-draw\n        if (Math.abs(edge.sourceIndex - edge.targetIndex) > 1) {\n          // get the length of link in column\n          const columns = _.range(edge.sourceIndex - 1, edge.targetIndex);\n          const chunkIndex = Math.floor(edge.sourceY / nodeMargin);\n          const targetChunkIndex = Math.floor(edge.targetY / nodeMargin);\n          // check upper paths\n          let northCost = 1;\n          let aboveRowIndex = chunkIndex;\n          for (; aboveRowIndex >= 0; aboveRowIndex--, northCost++) {\n            if (_.every(columns, columnIndex => {\n              return !(chunks[columnIndex][aboveRowIndex] || chunks[columnIndex + 0.5][aboveRowIndex] || chunks[columnIndex - 0.5][aboveRowIndex]);\n            })) {\n              break;\n            }\n          }\n          // check lower paths\n          let southCost = 0;\n          let belowRowIndex = chunkIndex;\n          for (; belowRowIndex <= maxChunkRowIndex; belowRowIndex++, southCost++) {\n            if (_.every(columns, columnIndex => {\n              return !(chunks[columnIndex][belowRowIndex] || chunks[columnIndex + 0.5][belowRowIndex] || chunks[columnIndex - 0.5][belowRowIndex]);\n            })) {\n              break;\n            }\n          }\n          // pick the cheapest path\n          const pathRowIndex = southCost + (belowRowIndex - targetChunkIndex) < northCost + (targetChunkIndex - aboveRowIndex) ? belowRowIndex + 1 : aboveRowIndex - 1;\n          // Finally update the link points\n          const points = [link.getFirstPoint()];\n          points.push(new PointModel({\n            link: link,\n            position: new Point((verticalLines[columns[0]] + verticalLines[columns[0] + 1]) / 2, (pathRowIndex + 0.5) * nodeMargin)\n          }));\n          _.forEach(columns, column => {\n            points.push(new PointModel({\n              link: link,\n              position: new Point(verticalLines[column], (pathRowIndex + 0.5) * nodeMargin)\n            }));\n            points.push(new PointModel({\n              link: link,\n              position: new Point((verticalLines[column] + verticalLines[column - 1]) / 2, (pathRowIndex + 0.5) * nodeMargin)\n            }));\n            chunks[column][pathRowIndex] = true;\n            chunks[column][pathRowIndex + 1] = true;\n            chunks[column + 0.5][pathRowIndex] = true;\n            chunks[column + 0.5][pathRowIndex + 1] = true;\n          });\n          link.setPoints(points.concat(link.getLastPoint()));\n        } else {\n          // refresh\n          link.setPoints([link.getFirstPoint(), link.getLastPoint()]);\n          const columnIndex = (edge.sourceIndex + edge.targetIndex) / 2;\n          if (!chunks[columnIndex]) {\n            chunks[columnIndex] = {};\n          }\n          const rowIndex = Math.floor((edge.sourceY + edge.targetY) / 2 / nodeMargin);\n          chunks[columnIndex][rowIndex] = true;\n          chunks[columnIndex][rowIndex + 1] = true;\n        }\n      });\n    }\n  }\n}","map":{"version":3,"names":["PointModel","dagre","_","Point","DagreEngine","constructor","options","redistribute","model","g","graphlib","Graph","multigraph","compound","setGraph","graph","setDefaultEdgeLabel","forEach","getNodes","node","setNode","getID","width","height","getLinks","link","getSourcePort","getTargetPort","setEdge","v","getNode","w","name","layout","nodes","setPosition","x","y","includeLinks","edges","e","edge","getLink","points","getFirstPoint","i","length","push","position","setPoints","concat","getLastPoint","refreshLinks","diagram","nodeMargin","links","maxChunkRowIndex","chunks","NodeXColumnIndexDictionary","verticalLines","nodeColumnCenter","getX","every","vLine","Math","abs","sort","a","b","line","index","startChunkIndex","floor","getY","endChunkIndex","nodeColumnIndex","findIndex","range","chunkIndex","map","source","target","sourceIndex","targetIndex","sourceY","targetY","sortedEdges","sortBy","columns","targetChunkIndex","northCost","aboveRowIndex","columnIndex","southCost","belowRowIndex","pathRowIndex","column","rowIndex"],"sources":["C:\\Users\\samir\\Diagram gen\\diagram-sami\\node_modules\\@projectstorm\\react-diagrams-routing\\src\\dagre\\DagreEngine.ts"],"sourcesContent":["import { DiagramModel, PointModel } from '@projectstorm/react-diagrams-core';\nimport * as dagre from 'dagre';\nimport { GraphLabel } from 'dagre';\nimport * as _ from 'lodash';\nimport { Point } from '@projectstorm/geometry';\n\nexport interface DagreEngineOptions {\n\tgraph?: GraphLabel;\n\t/**\n\t * Will also re-layout links\n\t */\n\tincludeLinks?: boolean;\n\tnodeMargin?: number;\n}\n\nexport class DagreEngine {\n\toptions: DagreEngineOptions;\n\n\tconstructor(options: DagreEngineOptions = {}) {\n\t\tthis.options = options;\n\t}\n\n\tredistribute(model: DiagramModel) {\n\t\t// Create a new directed graph\n\t\tvar g = new dagre.graphlib.Graph({\n\t\t\tmultigraph: true,\n\t\t\tcompound: true\n\t\t});\n\t\tg.setGraph(this.options.graph || {});\n\t\tg.setDefaultEdgeLabel(function () {\n\t\t\treturn {};\n\t\t});\n\n\t\t// set nodes\n\t\t_.forEach(model.getNodes(), (node) => {\n\t\t\tg.setNode(node.getID(), { width: node.width, height: node.height });\n\t\t});\n\n\t\t_.forEach(model.getLinks(), (link) => {\n\t\t\t// set edges\n\t\t\tif (link.getSourcePort() && link.getTargetPort()) {\n\t\t\t\tg.setEdge({\n\t\t\t\t\tv: link.getSourcePort().getNode().getID(),\n\t\t\t\t\tw: link.getTargetPort().getNode().getID(),\n\t\t\t\t\tname: link.getID()\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// layout the graph\n\t\tdagre.layout(g);\n\n\t\tg.nodes().forEach((v) => {\n\t\t\tconst node = g.node(v);\n\t\t\tmodel.getNode(v).setPosition(node.x - node.width / 2, node.y - node.height / 2);\n\t\t});\n\n\t\t// also include links?\n\t\tif (this.options.includeLinks) {\n\t\t\tg.edges().forEach((e) => {\n\t\t\t\tconst edge = g.edge(e);\n\t\t\t\tconst link = model.getLink(e.name);\n\n\t\t\t\tconst points = [link.getFirstPoint()];\n\t\t\t\tfor (let i = 1; i < edge.points.length - 1; i++) {\n\t\t\t\t\tpoints.push(new PointModel({ link: link, position: new Point(edge.points[i].x, edge.points[i].y) }));\n\t\t\t\t}\n\t\t\t\tlink.setPoints(points.concat(link.getLastPoint()));\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * TODO cleanup this method into smaller methods\n\t */\n\tpublic refreshLinks(diagram: DiagramModel) {\n\t\tconst { nodeMargin } = this.options;\n\t\tconst nodes = diagram.getNodes();\n\t\tconst links = diagram.getLinks();\n\t\tlet maxChunkRowIndex = -1;\n\t\t// build the chunk matrix\n\t\tconst chunks: { [id: number]: { [id: number]: boolean } } = {}; // true: occupied, false: blank\n\t\tconst NodeXColumnIndexDictionary: { [id: number]: number } = {};\n\t\tlet verticalLines: number[] = [];\n\t\t_.forEach(nodes, (node) => {\n\t\t\t// find vertical lines. vertical lines go through maximum number of nodes located under each other.\n\t\t\tconst nodeColumnCenter = node.getX() + node.width / 2;\n\t\t\tif (\n\t\t\t\t_.every(verticalLines, (vLine) => {\n\t\t\t\t\treturn Math.abs(nodeColumnCenter - vLine) > nodeMargin;\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tverticalLines.push(nodeColumnCenter);\n\t\t\t}\n\t\t});\n\n\t\t// sort chunk columns\n\t\tverticalLines = verticalLines.sort((a, b) => a - b);\n\t\t_.forEach(verticalLines, (line, index) => {\n\t\t\tchunks[index] = {};\n\t\t\tchunks[index + 0.5] = {};\n\t\t});\n\n\t\t// set occupied chunks\n\t\t_.forEach(nodes, (node) => {\n\t\t\tconst nodeColumnCenter = node.getX() + node.width / 2;\n\t\t\tconst startChunkIndex = Math.floor(node.getY() / nodeMargin);\n\t\t\tconst endChunkIndex = Math.floor((node.getY() + node.height) / nodeMargin);\n\t\t\t// find max ChunkRowIndex\n\t\t\tif (endChunkIndex > maxChunkRowIndex) maxChunkRowIndex = endChunkIndex;\n\t\t\tconst nodeColumnIndex = _.findIndex(verticalLines, (vLine) => {\n\t\t\t\treturn Math.abs(nodeColumnCenter - vLine) <= nodeMargin;\n\t\t\t});\n\t\t\t_.forEach(_.range(startChunkIndex, endChunkIndex + 1), (chunkIndex) => {\n\t\t\t\tchunks[nodeColumnIndex][chunkIndex] = true;\n\t\t\t});\n\t\t\tNodeXColumnIndexDictionary[node.getX()] = nodeColumnIndex;\n\t\t});\n\n\t\t// sort links based on their distances\n\t\tconst edges = _.map(links, (link) => {\n\t\t\tif (link.getSourcePort() && link.getTargetPort()) {\n\t\t\t\tconst source = link.getSourcePort().getNode();\n\t\t\t\tconst target = link.getTargetPort().getNode();\n\t\t\t\tconst sourceIndex = NodeXColumnIndexDictionary[source.getX()];\n\t\t\t\tconst targetIndex = NodeXColumnIndexDictionary[target.getX()];\n\n\t\t\t\treturn sourceIndex > targetIndex\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tlink,\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tsourceY: source.getY() + source.height / 2,\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttargetIndex,\n\t\t\t\t\t\t\ttargetY: target.getY() + source.height / 2,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tlink,\n\t\t\t\t\t\t\tsourceIndex: targetIndex,\n\t\t\t\t\t\t\tsourceY: target.getY() + target.height / 2,\n\t\t\t\t\t\t\tsource: target,\n\t\t\t\t\t\t\ttargetIndex: sourceIndex,\n\t\t\t\t\t\t\ttargetY: source.getY() + source.height / 2,\n\t\t\t\t\t\t\ttarget: source\n\t\t\t\t\t  };\n\t\t\t}\n\t\t});\n\t\tconst sortedEdges = _.sortBy(edges, (link) => {\n\t\t\treturn Math.abs(link.targetIndex - link.sourceIndex);\n\t\t});\n\n\t\t// set link points\n\t\tif (this.options.includeLinks) {\n\t\t\t_.forEach(sortedEdges, (edge) => {\n\t\t\t\tconst link = diagram.getLink(edge.link.getID());\n\t\t\t\t// re-draw\n\t\t\t\tif (Math.abs(edge.sourceIndex - edge.targetIndex) > 1) {\n\t\t\t\t\t// get the length of link in column\n\t\t\t\t\tconst columns = _.range(edge.sourceIndex - 1, edge.targetIndex);\n\n\t\t\t\t\tconst chunkIndex = Math.floor(edge.sourceY / nodeMargin);\n\t\t\t\t\tconst targetChunkIndex = Math.floor(edge.targetY / nodeMargin);\n\n\t\t\t\t\t// check upper paths\n\t\t\t\t\tlet northCost = 1;\n\t\t\t\t\tlet aboveRowIndex = chunkIndex;\n\t\t\t\t\tfor (; aboveRowIndex >= 0; aboveRowIndex--, northCost++) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t_.every(columns, (columnIndex) => {\n\t\t\t\t\t\t\t\treturn !(\n\t\t\t\t\t\t\t\t\tchunks[columnIndex][aboveRowIndex] ||\n\t\t\t\t\t\t\t\t\tchunks[columnIndex + 0.5][aboveRowIndex] ||\n\t\t\t\t\t\t\t\t\tchunks[columnIndex - 0.5][aboveRowIndex]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// check lower paths\n\t\t\t\t\tlet southCost = 0;\n\t\t\t\t\tlet belowRowIndex = chunkIndex;\n\t\t\t\t\tfor (; belowRowIndex <= maxChunkRowIndex; belowRowIndex++, southCost++) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t_.every(columns, (columnIndex) => {\n\t\t\t\t\t\t\t\treturn !(\n\t\t\t\t\t\t\t\t\tchunks[columnIndex][belowRowIndex] ||\n\t\t\t\t\t\t\t\t\tchunks[columnIndex + 0.5][belowRowIndex] ||\n\t\t\t\t\t\t\t\t\tchunks[columnIndex - 0.5][belowRowIndex]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// pick the cheapest path\n\t\t\t\t\tconst pathRowIndex =\n\t\t\t\t\t\tsouthCost + (belowRowIndex - targetChunkIndex) < northCost + (targetChunkIndex - aboveRowIndex)\n\t\t\t\t\t\t\t? belowRowIndex + 1\n\t\t\t\t\t\t\t: aboveRowIndex - 1;\n\n\t\t\t\t\t// Finally update the link points\n\t\t\t\t\tconst points = [link.getFirstPoint()];\n\t\t\t\t\tpoints.push(\n\t\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\t\tlink: link,\n\t\t\t\t\t\t\tposition: new Point(\n\t\t\t\t\t\t\t\t(verticalLines[columns[0]] + verticalLines[columns[0] + 1]) / 2,\n\t\t\t\t\t\t\t\t(pathRowIndex + 0.5) * nodeMargin\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\n\t\t\t\t\t_.forEach(columns, (column) => {\n\t\t\t\t\t\tpoints.push(\n\t\t\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\t\t\tlink: link,\n\t\t\t\t\t\t\t\tposition: new Point(verticalLines[column], (pathRowIndex + 0.5) * nodeMargin)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t\tpoints.push(\n\t\t\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\t\t\tlink: link,\n\t\t\t\t\t\t\t\tposition: new Point(\n\t\t\t\t\t\t\t\t\t(verticalLines[column] + verticalLines[column - 1]) / 2,\n\t\t\t\t\t\t\t\t\t(pathRowIndex + 0.5) * nodeMargin\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t\tchunks[column][pathRowIndex] = true;\n\t\t\t\t\t\tchunks[column][pathRowIndex + 1] = true;\n\t\t\t\t\t\tchunks[column + 0.5][pathRowIndex] = true;\n\t\t\t\t\t\tchunks[column + 0.5][pathRowIndex + 1] = true;\n\t\t\t\t\t});\n\t\t\t\t\tlink.setPoints(points.concat(link.getLastPoint()));\n\t\t\t\t} else {\n\t\t\t\t\t// refresh\n\t\t\t\t\tlink.setPoints([link.getFirstPoint(), link.getLastPoint()]);\n\t\t\t\t\tconst columnIndex = (edge.sourceIndex + edge.targetIndex) / 2;\n\t\t\t\t\tif (!chunks[columnIndex]) {\n\t\t\t\t\t\tchunks[columnIndex] = {};\n\t\t\t\t\t}\n\t\t\t\t\tconst rowIndex = Math.floor((edge.sourceY + edge.targetY) / 2 / nodeMargin);\n\t\t\t\t\tchunks[columnIndex][rowIndex] = true;\n\t\t\t\t\tchunks[columnIndex][rowIndex + 1] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}