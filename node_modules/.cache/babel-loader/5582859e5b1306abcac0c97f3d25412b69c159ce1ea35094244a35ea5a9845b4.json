{"ast":null,"code":"import { Action, InputType } from '../core-actions/Action';\nexport class PanAndZoomCanvasAction extends Action {\n  constructor(options = {}) {\n    super({\n      type: InputType.MOUSE_WHEEL,\n      fire: actionEvent => {\n        const {\n          event\n        } = actionEvent;\n        // we can block layer rendering because we are only targeting the transforms\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(false);\n        }\n        const model = this.engine.getModel();\n        event.stopPropagation();\n        if (event.ctrlKey) {\n          // Pinch and zoom gesture\n          const oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n          let scrollDelta = options.inverseZoom ? event.deltaY : -event.deltaY;\n          scrollDelta /= 3;\n          if (model.getZoomLevel() + scrollDelta > 10) {\n            model.setZoomLevel(model.getZoomLevel() + scrollDelta);\n          }\n          const zoomFactor = model.getZoomLevel() / 100;\n          const boundingRect = event.currentTarget.getBoundingClientRect();\n          const clientWidth = boundingRect.width;\n          const clientHeight = boundingRect.height;\n          // compute difference between rect before and after scroll\n          const widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n          const heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n          // compute mouse coords relative to canvas\n          const clientX = event.clientX - boundingRect.left;\n          const clientY = event.clientY - boundingRect.top;\n          // compute width and height increment factor\n          const xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n          const yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n          model.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n        } else {\n          // Pan gesture\n          let yDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\n          let xDelta = options.inverseZoom ? -event.deltaX : event.deltaX;\n          model.setOffset(model.getOffsetX() - xDelta, model.getOffsetY() - yDelta);\n        }\n        this.engine.repaintCanvas();\n        // re-enable rendering\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(true);\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["Action","InputType","PanAndZoomCanvasAction","constructor","options","type","MOUSE_WHEEL","fire","actionEvent","event","layer","engine","getModel","getLayers","allowRepaint","model","stopPropagation","ctrlKey","oldZoomFactor","getZoomLevel","scrollDelta","inverseZoom","deltaY","setZoomLevel","zoomFactor","boundingRect","currentTarget","getBoundingClientRect","clientWidth","width","clientHeight","height","widthDiff","heightDiff","clientX","left","clientY","top","xFactor","getOffsetX","yFactor","getOffsetY","setOffset","yDelta","xDelta","deltaX","repaintCanvas"],"sources":["C:\\Users\\samir\\Diagram gen\\diagram-sami\\node_modules\\@projectstorm\\react-canvas-core\\src\\actions\\PanAndZoomCanvasAction.ts"],"sourcesContent":["import { WheelEvent } from 'react';\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\n\nexport interface PanAndZoomCanvasActionOptions {\n\tinverseZoom?: boolean;\n}\n\nexport class PanAndZoomCanvasAction extends Action {\n\tconstructor(options: PanAndZoomCanvasActionOptions = {}) {\n\t\tsuper({\n\t\t\ttype: InputType.MOUSE_WHEEL,\n\t\t\tfire: (actionEvent: ActionEvent<WheelEvent>) => {\n\t\t\t\tconst { event } = actionEvent;\n\t\t\t\t// we can block layer rendering because we are only targeting the transforms\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\n\t\t\t\t\tlayer.allowRepaint(false);\n\t\t\t\t}\n\n\t\t\t\tconst model = this.engine.getModel();\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tif (event.ctrlKey) {\n\t\t\t\t\t// Pinch and zoom gesture\n\t\t\t\t\tconst oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n\n\t\t\t\t\tlet scrollDelta = options.inverseZoom ? event.deltaY : -event.deltaY;\n\t\t\t\t\tscrollDelta /= 3;\n\n\t\t\t\t\tif (model.getZoomLevel() + scrollDelta > 10) {\n\t\t\t\t\t\tmodel.setZoomLevel(model.getZoomLevel() + scrollDelta);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst zoomFactor = model.getZoomLevel() / 100;\n\n\t\t\t\t\tconst boundingRect = event.currentTarget.getBoundingClientRect();\n\t\t\t\t\tconst clientWidth = boundingRect.width;\n\t\t\t\t\tconst clientHeight = boundingRect.height;\n\t\t\t\t\t// compute difference between rect before and after scroll\n\t\t\t\t\tconst widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n\t\t\t\t\tconst heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n\t\t\t\t\t// compute mouse coords relative to canvas\n\t\t\t\t\tconst clientX = event.clientX - boundingRect.left;\n\t\t\t\t\tconst clientY = event.clientY - boundingRect.top;\n\n\t\t\t\t\t// compute width and height increment factor\n\t\t\t\t\tconst xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n\t\t\t\t\tconst yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n\n\t\t\t\t\tmodel.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n\t\t\t\t} else {\n\t\t\t\t\t// Pan gesture\n\t\t\t\t\tlet yDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\n\t\t\t\t\tlet xDelta = options.inverseZoom ? -event.deltaX : event.deltaX;\n\t\t\t\t\tmodel.setOffset(model.getOffsetX() - xDelta, model.getOffsetY() - yDelta);\n\t\t\t\t}\n\t\t\t\tthis.engine.repaintCanvas();\n\n\t\t\t\t// re-enable rendering\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\n\t\t\t\t\tlayer.allowRepaint(true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}