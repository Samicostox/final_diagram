{"ast":null,"code":"/**\r\n * @author imor / https://github.com/imor\r\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\nfunction JPFAlwaysMoveDiagonally(opt) {\n  JumpPointFinderBase.call(this, opt);\n}\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\n\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\nJPFAlwaysMoveDiagonally.prototype._jump = function (x, y, px, py) {\n  var grid = this.grid,\n    dx = x - px,\n    dy = y - py;\n  if (!grid.isWalkableAt(x, y)) {\n    return null;\n  }\n  if (this.trackJumpRecursion === true) {\n    grid.getNodeAt(x, y).tested = true;\n  }\n  if (grid.getNodeAt(x, y) === this.endNode) {\n    return [x, y];\n  }\n\n  // check for forced neighbors\n  // along the diagonal\n  if (dx !== 0 && dy !== 0) {\n    if (grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y) || grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy)) {\n      return [x, y];\n    }\n    // when moving diagonally, must check for vertical/horizontal jump points\n    if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n      return [x, y];\n    }\n  }\n  // horizontally/vertically\n  else {\n    if (dx !== 0) {\n      // moving along x\n      if (grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1) || grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1)) {\n        return [x, y];\n      }\n    } else {\n      if (grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y) || grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y)) {\n        return [x, y];\n      }\n    }\n  }\n  return this._jump(x + dx, y + dy, x, y);\n};\n\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function (node) {\n  var parent = node.parent,\n    x = node.x,\n    y = node.y,\n    grid = this.grid,\n    px,\n    py,\n    nx,\n    ny,\n    dx,\n    dy,\n    neighbors = [],\n    neighborNodes,\n    neighborNode,\n    i,\n    l;\n\n  // directed pruning: can ignore most neighbors, unless forced.\n  if (parent) {\n    px = parent.x;\n    py = parent.y;\n    // get the normalized direction of travel\n    dx = (x - px) / Math.max(Math.abs(x - px), 1);\n    dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n    // search diagonally\n    if (dx !== 0 && dy !== 0) {\n      if (grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x, y + dy]);\n      }\n      if (grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y]);\n      }\n      if (grid.isWalkableAt(x + dx, y + dy)) {\n        neighbors.push([x + dx, y + dy]);\n      }\n      if (!grid.isWalkableAt(x - dx, y)) {\n        neighbors.push([x - dx, y + dy]);\n      }\n      if (!grid.isWalkableAt(x, y - dy)) {\n        neighbors.push([x + dx, y - dy]);\n      }\n    }\n    // search horizontally/vertically\n    else {\n      if (dx === 0) {\n        if (grid.isWalkableAt(x, y + dy)) {\n          neighbors.push([x, y + dy]);\n        }\n        if (!grid.isWalkableAt(x + 1, y)) {\n          neighbors.push([x + 1, y + dy]);\n        }\n        if (!grid.isWalkableAt(x - 1, y)) {\n          neighbors.push([x - 1, y + dy]);\n        }\n      } else {\n        if (grid.isWalkableAt(x + dx, y)) {\n          neighbors.push([x + dx, y]);\n        }\n        if (!grid.isWalkableAt(x, y + 1)) {\n          neighbors.push([x + dx, y + 1]);\n        }\n        if (!grid.isWalkableAt(x, y - 1)) {\n          neighbors.push([x + dx, y - 1]);\n        }\n      }\n    }\n  }\n  // return all neighbors\n  else {\n    neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\n    for (i = 0, l = neighborNodes.length; i < l; ++i) {\n      neighborNode = neighborNodes[i];\n      neighbors.push([neighborNode.x, neighborNode.y]);\n    }\n  }\n  return neighbors;\n};\nmodule.exports = JPFAlwaysMoveDiagonally;","map":{"version":3,"names":["JumpPointFinderBase","require","DiagonalMovement","JPFAlwaysMoveDiagonally","opt","call","prototype","constructor","_jump","x","y","px","py","grid","dx","dy","isWalkableAt","trackJumpRecursion","getNodeAt","tested","endNode","_findNeighbors","node","parent","nx","ny","neighbors","neighborNodes","neighborNode","i","l","Math","max","abs","push","getNeighbors","Always","length","module","exports"],"sources":["C:/Users/samir/Diagram gen/diagram-sami/node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js"],"sourcesContent":["/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}