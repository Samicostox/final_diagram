{"ast":null,"code":"var Util = require('../core/Util');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\nfunction BiBreadthFirstFinder(opt) {\n  opt = opt || {};\n  this.allowDiagonal = opt.allowDiagonal;\n  this.dontCrossCorners = opt.dontCrossCorners;\n  this.diagonalMovement = opt.diagonalMovement;\n  if (!this.diagonalMovement) {\n    if (!this.allowDiagonal) {\n      this.diagonalMovement = DiagonalMovement.Never;\n    } else {\n      if (this.dontCrossCorners) {\n        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n      } else {\n        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n      }\n    }\n  }\n}\n\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\nBiBreadthFirstFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var startNode = grid.getNodeAt(startX, startY),\n    endNode = grid.getNodeAt(endX, endY),\n    startOpenList = [],\n    endOpenList = [],\n    neighbors,\n    neighbor,\n    node,\n    diagonalMovement = this.diagonalMovement,\n    BY_START = 0,\n    BY_END = 1,\n    i,\n    l;\n\n  // push the start and end nodes into the queues\n  startOpenList.push(startNode);\n  startNode.opened = true;\n  startNode.by = BY_START;\n  endOpenList.push(endNode);\n  endNode.opened = true;\n  endNode.by = BY_END;\n\n  // while both the queues are not empty\n  while (startOpenList.length && endOpenList.length) {\n    // expand start open list\n\n    node = startOpenList.shift();\n    node.closed = true;\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n      if (neighbor.closed) {\n        continue;\n      }\n      if (neighbor.opened) {\n        // if this node has been inspected by the reversed search,\n        // then a path is found.\n        if (neighbor.by === BY_END) {\n          return Util.biBacktrace(node, neighbor);\n        }\n        continue;\n      }\n      startOpenList.push(neighbor);\n      neighbor.parent = node;\n      neighbor.opened = true;\n      neighbor.by = BY_START;\n    }\n\n    // expand end open list\n\n    node = endOpenList.shift();\n    node.closed = true;\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n      if (neighbor.closed) {\n        continue;\n      }\n      if (neighbor.opened) {\n        if (neighbor.by === BY_START) {\n          return Util.biBacktrace(neighbor, node);\n        }\n        continue;\n      }\n      endOpenList.push(neighbor);\n      neighbor.parent = node;\n      neighbor.opened = true;\n      neighbor.by = BY_END;\n    }\n  }\n\n  // fail to find the path\n  return [];\n};\nmodule.exports = BiBreadthFirstFinder;","map":{"version":3,"names":["Util","require","DiagonalMovement","BiBreadthFirstFinder","opt","allowDiagonal","dontCrossCorners","diagonalMovement","Never","OnlyWhenNoObstacles","IfAtMostOneObstacle","prototype","findPath","startX","startY","endX","endY","grid","startNode","getNodeAt","endNode","startOpenList","endOpenList","neighbors","neighbor","node","BY_START","BY_END","i","l","push","opened","by","length","shift","closed","getNeighbors","biBacktrace","parent","module","exports"],"sources":["C:/Users/samir/Diagram gen/diagram-sami/node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js"],"sourcesContent":["var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}